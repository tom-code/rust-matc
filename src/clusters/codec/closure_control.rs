//! Matter TLV encoders and decoders for Closure Control Cluster
//! Cluster ID: 0x0104
//!
//! This file is automatically generated from ClosureControl.xml

use crate::tlv;
use anyhow;
use serde_json;


// Enum definitions

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ClosureError {
    /// An obstacle is blocking the closure movement
    Physicallyblocked = 0,
    /// The closure is unsafe to move, as determined by a sensor (e.g. photoelectric sensor) before attempting movement
    Blockedbysensor = 1,
    /// A warning raised by the closure that indicates an over-temperature, e.g. due to excessive drive or stall current
    Temperaturelimited = 2,
    /// Some malfunctions that are not easily recoverable are detected, or urgent servicing is needed
    Maintenancerequired = 3,
    /// An internal element is prohibiting motion, e.g. an integrated door within a bigger garage door is open and prevents motion
    Internalinterference = 4,
}

impl ClosureError {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(ClosureError::Physicallyblocked),
            1 => Some(ClosureError::Blockedbysensor),
            2 => Some(ClosureError::Temperaturelimited),
            3 => Some(ClosureError::Maintenancerequired),
            4 => Some(ClosureError::Internalinterference),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<ClosureError> for u8 {
    fn from(val: ClosureError) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum CurrentPosition {
    /// Fully closed state
    Fullyclosed = 0,
    /// Fully opened state
    Fullyopened = 1,
    /// Partially opened state (closure is not fully opened or fully closed)
    Partiallyopened = 2,
    /// Closure is in the Pedestrian position
    Openedforpedestrian = 3,
    /// Closure is in the Ventilation position
    Openedforventilation = 4,
    /// Closure is in its "Signature position"
    Openedatsignature = 5,
}

impl CurrentPosition {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(CurrentPosition::Fullyclosed),
            1 => Some(CurrentPosition::Fullyopened),
            2 => Some(CurrentPosition::Partiallyopened),
            3 => Some(CurrentPosition::Openedforpedestrian),
            4 => Some(CurrentPosition::Openedforventilation),
            5 => Some(CurrentPosition::Openedatsignature),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<CurrentPosition> for u8 {
    fn from(val: CurrentPosition) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum MainState {
    /// Closure is stopped
    Stopped = 0,
    /// Closure is actively moving
    Moving = 1,
    /// Closure is waiting before a motion (e.g. pre-heat, pre-check)
    Waitingformotion = 2,
    /// Closure is in an error state
    Error = 3,
    /// Closure is currently calibrating its Opened and Closed limits to determine effective physical range
    Calibrating = 4,
    /// Some protective measures are activated to prevent damage to the closure. Commands MAY be rejected.
    Protected = 5,
    /// Closure has a disengaged element preventing any actuator movements
    Disengaged = 6,
    /// Movement commands are ignored since the closure is not operational and requires further setup and/or calibration
    Setuprequired = 7,
}

impl MainState {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(MainState::Stopped),
            1 => Some(MainState::Moving),
            2 => Some(MainState::Waitingformotion),
            3 => Some(MainState::Error),
            4 => Some(MainState::Calibrating),
            5 => Some(MainState::Protected),
            6 => Some(MainState::Disengaged),
            7 => Some(MainState::Setuprequired),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<MainState> for u8 {
    fn from(val: MainState) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum TargetPosition {
    /// Move to a fully closed state
    Movetofullyclosed = 0,
    /// Move to a fully open state
    Movetofullyopen = 1,
    /// Move to the Pedestrian position
    Movetopedestrianposition = 2,
    /// Move to the Ventilation position
    Movetoventilationposition = 3,
    /// Move to the Signature position
    Movetosignatureposition = 4,
}

impl TargetPosition {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(TargetPosition::Movetofullyclosed),
            1 => Some(TargetPosition::Movetofullyopen),
            2 => Some(TargetPosition::Movetopedestrianposition),
            3 => Some(TargetPosition::Movetoventilationposition),
            4 => Some(TargetPosition::Movetosignatureposition),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<TargetPosition> for u8 {
    fn from(val: TargetPosition) -> Self {
        val as u8
    }
}

// Bitmap definitions

/// LatchControlModes bitmap type
pub type LatchControlModes = u8;

/// Constants for LatchControlModes
pub mod latchcontrolmodes {
    /// Remote latching capability
    pub const REMOTE_LATCHING: u8 = 0x01;
    /// Remote unlatching capability
    pub const REMOTE_UNLATCHING: u8 = 0x02;
}

// Struct definitions

#[derive(Debug, serde::Serialize)]
pub struct OverallCurrentState {
    pub position: Option<CurrentPosition>,
    pub latch: Option<bool>,
    pub speed: Option<u8>,
    pub secure_state: Option<bool>,
}

#[derive(Debug, serde::Serialize)]
pub struct OverallTargetState {
    pub position: Option<TargetPosition>,
    pub latch: Option<bool>,
    pub speed: Option<u8>,
}

// Command encoders

/// Encode MoveTo command (0x01)
pub fn encode_move_to(position: TargetPosition, latch: bool, speed: u8) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(position.to_u8())).into(),
        (1, tlv::TlvItemValueEnc::Bool(latch)).into(),
        (2, tlv::TlvItemValueEnc::UInt8(speed)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

// Attribute decoders

/// Decode CountdownTime attribute (0x0000)
pub fn decode_countdown_time(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u32>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u32))
    } else {
        Ok(None)
    }
}

/// Decode MainState attribute (0x0001)
pub fn decode_main_state(inp: &tlv::TlvItemValue) -> anyhow::Result<MainState> {
    if let tlv::TlvItemValue::Int(v) = inp {
        MainState::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode CurrentErrorList attribute (0x0002)
pub fn decode_current_error_list(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<ClosureError>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            if let tlv::TlvItemValue::Int(i) = &item.value {
                if let Some(enum_val) = ClosureError::from_u8(*i as u8) {
                    res.push(enum_val);
                }
            }
        }
    }
    Ok(res)
}

/// Decode OverallCurrentState attribute (0x0003)
pub fn decode_overall_current_state(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<OverallCurrentState>> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        // Struct with fields
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(Some(OverallCurrentState {
                position: item.get_int(&[0]).and_then(|v| CurrentPosition::from_u8(v as u8)),
                latch: item.get_bool(&[1]),
                speed: item.get_int(&[2]).map(|v| v as u8),
                secure_state: item.get_bool(&[3]),
        }))
    //} else if let tlv::TlvItemValue::Null = inp {
    //    // Null value for nullable struct
    //    Ok(None)
    } else {
    Ok(None)
    //    Err(anyhow::anyhow!("Expected struct fields or null"))
    }
}

/// Decode OverallTargetState attribute (0x0004)
pub fn decode_overall_target_state(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<OverallTargetState>> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        // Struct with fields
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(Some(OverallTargetState {
                position: item.get_int(&[0]).and_then(|v| TargetPosition::from_u8(v as u8)),
                latch: item.get_bool(&[1]),
                speed: item.get_int(&[2]).map(|v| v as u8),
        }))
    //} else if let tlv::TlvItemValue::Null = inp {
    //    // Null value for nullable struct
    //    Ok(None)
    } else {
    Ok(None)
    //    Err(anyhow::anyhow!("Expected struct fields or null"))
    }
}

/// Decode LatchControlModes attribute (0x0005)
pub fn decode_latch_control_modes(inp: &tlv::TlvItemValue) -> anyhow::Result<LatchControlModes> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}


// JSON dispatcher function

/// Decode attribute value and return as JSON string
///
/// # Parameters
/// * `cluster_id` - The cluster identifier
/// * `attribute_id` - The attribute identifier
/// * `tlv_value` - The TLV value to decode
///
/// # Returns
/// JSON string representation of the decoded value or error
pub fn decode_attribute_json(cluster_id: u32, attribute_id: u32, tlv_value: &crate::tlv::TlvItemValue) -> String {
    // Verify this is the correct cluster
    if cluster_id != 0x0104 {
        return format!("{{\"error\": \"Invalid cluster ID. Expected 0x0104, got {}\"}}", cluster_id);
    }

    match attribute_id {
        0x0000 => {
            match decode_countdown_time(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0001 => {
            match decode_main_state(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0002 => {
            match decode_current_error_list(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0003 => {
            match decode_overall_current_state(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0004 => {
            match decode_overall_target_state(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0005 => {
            match decode_latch_control_modes(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        _ => format!("{{\"error\": \"Unknown attribute ID: {}\"}}", attribute_id),
    }
}

/// Get list of all attributes supported by this cluster
///
/// # Returns
/// Vector of tuples containing (attribute_id, attribute_name)
pub fn get_attribute_list() -> Vec<(u32, &'static str)> {
    vec![
        (0x0000, "CountdownTime"),
        (0x0001, "MainState"),
        (0x0002, "CurrentErrorList"),
        (0x0003, "OverallCurrentState"),
        (0x0004, "OverallTargetState"),
        (0x0005, "LatchControlModes"),
    ]
}

#[derive(Debug, serde::Serialize)]
pub struct OperationalErrorEvent {
    pub error_state: Option<Vec<ClosureError>>,
}

#[derive(Debug, serde::Serialize)]
pub struct EngageStateChangedEvent {
    pub engage_value: Option<bool>,
}

#[derive(Debug, serde::Serialize)]
pub struct SecureStateChangedEvent {
    pub secure_value: Option<bool>,
}

// Event decoders

/// Decode OperationalError event (0x00, priority: critical)
pub fn decode_operational_error_event(inp: &tlv::TlvItemValue) -> anyhow::Result<OperationalErrorEvent> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(OperationalErrorEvent {
                                error_state: {
                    if let Some(tlv::TlvItemValue::List(l)) = item.get(&[0]) {
                        let items: Vec<ClosureError> = l.iter().filter_map(|e| { if let tlv::TlvItemValue::Int(v) = &e.value { ClosureError::from_u8(*v as u8) } else { None } }).collect();
                        Some(items)
                    } else {
                        None
                    }
                },
        })
    } else {
        Err(anyhow::anyhow!("Expected struct fields"))
    }
}

/// Decode EngageStateChanged event (0x02, priority: info)
pub fn decode_engage_state_changed_event(inp: &tlv::TlvItemValue) -> anyhow::Result<EngageStateChangedEvent> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(EngageStateChangedEvent {
                                engage_value: item.get_bool(&[0]),
        })
    } else {
        Err(anyhow::anyhow!("Expected struct fields"))
    }
}

/// Decode SecureStateChanged event (0x03, priority: info)
pub fn decode_secure_state_changed_event(inp: &tlv::TlvItemValue) -> anyhow::Result<SecureStateChangedEvent> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(SecureStateChangedEvent {
                                secure_value: item.get_bool(&[0]),
        })
    } else {
        Err(anyhow::anyhow!("Expected struct fields"))
    }
}

