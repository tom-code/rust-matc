//! Matter TLV encoders and decoders for Keypad Input Cluster
//! Cluster ID: 0x0509
//!
//! This file is automatically generated from KeypadInput.xml

use crate::tlv;
use anyhow;


// Enum definitions

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum CecKeyCode {
    Select = 0,
    Up = 1,
    Down = 2,
    Left = 3,
    Right = 4,
    Rightup = 5,
    Rightdown = 6,
    Leftup = 7,
    Leftdown = 8,
    Rootmenu = 9,
    Setupmenu = 10,
    Contentsmenu = 11,
    Favoritemenu = 12,
    Exit = 13,
    Mediatopmenu = 16,
    Mediacontextsensitivemenu = 17,
    Numberentrymode = 29,
    Number11 = 30,
    Number12 = 31,
    Number0ornumber10 = 32,
    Numbers1 = 33,
    Numbers2 = 34,
    Numbers3 = 35,
    Numbers4 = 36,
    Numbers5 = 37,
    Numbers6 = 38,
    Numbers7 = 39,
    Numbers8 = 40,
    Numbers9 = 41,
    Dot = 42,
    Enter = 43,
    Clear = 44,
    Nextfavorite = 47,
    Channelup = 48,
    Channeldown = 49,
    Previouschannel = 50,
    Soundselect = 51,
    Inputselect = 52,
    Displayinformation = 53,
    Help = 54,
    Pageup = 55,
    Pagedown = 56,
    Power = 64,
    Volumeup = 65,
    Volumedown = 66,
    Mute = 67,
    Play = 68,
    Stop = 69,
    Pause = 70,
    Record = 71,
    Rewind = 72,
    Fastforward = 73,
    Eject = 74,
    Forward = 75,
    Backward = 76,
    Stoprecord = 77,
    Pauserecord = 78,
    Reserved = 79,
    Angle = 80,
    Subpicture = 81,
    Videoondemand = 82,
    Electronicprogramguide = 83,
    Timerprogramming = 84,
    Initialconfiguration = 85,
    Selectbroadcasttype = 86,
    Selectsoundpresentation = 87,
    Playfunction = 96,
    Pauseplayfunction = 97,
    Recordfunction = 98,
    Pauserecordfunction = 99,
    Stopfunction = 100,
    Mutefunction = 101,
    Restorevolumefunction = 102,
    Tunefunction = 103,
    Selectmediafunction = 104,
    Selectavinputfunction = 105,
    Selectaudioinputfunction = 106,
    Powertogglefunction = 107,
    Powerofffunction = 108,
    Poweronfunction = 109,
    F1blue = 113,
    F2red = 114,
    F3green = 115,
    F4yellow = 116,
    F5 = 117,
    Data = 118,
}

impl CecKeyCode {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(CecKeyCode::Select),
            1 => Some(CecKeyCode::Up),
            2 => Some(CecKeyCode::Down),
            3 => Some(CecKeyCode::Left),
            4 => Some(CecKeyCode::Right),
            5 => Some(CecKeyCode::Rightup),
            6 => Some(CecKeyCode::Rightdown),
            7 => Some(CecKeyCode::Leftup),
            8 => Some(CecKeyCode::Leftdown),
            9 => Some(CecKeyCode::Rootmenu),
            10 => Some(CecKeyCode::Setupmenu),
            11 => Some(CecKeyCode::Contentsmenu),
            12 => Some(CecKeyCode::Favoritemenu),
            13 => Some(CecKeyCode::Exit),
            16 => Some(CecKeyCode::Mediatopmenu),
            17 => Some(CecKeyCode::Mediacontextsensitivemenu),
            29 => Some(CecKeyCode::Numberentrymode),
            30 => Some(CecKeyCode::Number11),
            31 => Some(CecKeyCode::Number12),
            32 => Some(CecKeyCode::Number0ornumber10),
            33 => Some(CecKeyCode::Numbers1),
            34 => Some(CecKeyCode::Numbers2),
            35 => Some(CecKeyCode::Numbers3),
            36 => Some(CecKeyCode::Numbers4),
            37 => Some(CecKeyCode::Numbers5),
            38 => Some(CecKeyCode::Numbers6),
            39 => Some(CecKeyCode::Numbers7),
            40 => Some(CecKeyCode::Numbers8),
            41 => Some(CecKeyCode::Numbers9),
            42 => Some(CecKeyCode::Dot),
            43 => Some(CecKeyCode::Enter),
            44 => Some(CecKeyCode::Clear),
            47 => Some(CecKeyCode::Nextfavorite),
            48 => Some(CecKeyCode::Channelup),
            49 => Some(CecKeyCode::Channeldown),
            50 => Some(CecKeyCode::Previouschannel),
            51 => Some(CecKeyCode::Soundselect),
            52 => Some(CecKeyCode::Inputselect),
            53 => Some(CecKeyCode::Displayinformation),
            54 => Some(CecKeyCode::Help),
            55 => Some(CecKeyCode::Pageup),
            56 => Some(CecKeyCode::Pagedown),
            64 => Some(CecKeyCode::Power),
            65 => Some(CecKeyCode::Volumeup),
            66 => Some(CecKeyCode::Volumedown),
            67 => Some(CecKeyCode::Mute),
            68 => Some(CecKeyCode::Play),
            69 => Some(CecKeyCode::Stop),
            70 => Some(CecKeyCode::Pause),
            71 => Some(CecKeyCode::Record),
            72 => Some(CecKeyCode::Rewind),
            73 => Some(CecKeyCode::Fastforward),
            74 => Some(CecKeyCode::Eject),
            75 => Some(CecKeyCode::Forward),
            76 => Some(CecKeyCode::Backward),
            77 => Some(CecKeyCode::Stoprecord),
            78 => Some(CecKeyCode::Pauserecord),
            79 => Some(CecKeyCode::Reserved),
            80 => Some(CecKeyCode::Angle),
            81 => Some(CecKeyCode::Subpicture),
            82 => Some(CecKeyCode::Videoondemand),
            83 => Some(CecKeyCode::Electronicprogramguide),
            84 => Some(CecKeyCode::Timerprogramming),
            85 => Some(CecKeyCode::Initialconfiguration),
            86 => Some(CecKeyCode::Selectbroadcasttype),
            87 => Some(CecKeyCode::Selectsoundpresentation),
            96 => Some(CecKeyCode::Playfunction),
            97 => Some(CecKeyCode::Pauseplayfunction),
            98 => Some(CecKeyCode::Recordfunction),
            99 => Some(CecKeyCode::Pauserecordfunction),
            100 => Some(CecKeyCode::Stopfunction),
            101 => Some(CecKeyCode::Mutefunction),
            102 => Some(CecKeyCode::Restorevolumefunction),
            103 => Some(CecKeyCode::Tunefunction),
            104 => Some(CecKeyCode::Selectmediafunction),
            105 => Some(CecKeyCode::Selectavinputfunction),
            106 => Some(CecKeyCode::Selectaudioinputfunction),
            107 => Some(CecKeyCode::Powertogglefunction),
            108 => Some(CecKeyCode::Powerofffunction),
            109 => Some(CecKeyCode::Poweronfunction),
            113 => Some(CecKeyCode::F1blue),
            114 => Some(CecKeyCode::F2red),
            115 => Some(CecKeyCode::F3green),
            116 => Some(CecKeyCode::F4yellow),
            117 => Some(CecKeyCode::F5),
            118 => Some(CecKeyCode::Data),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<CecKeyCode> for u8 {
    fn from(val: CecKeyCode) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum Status {
    /// Succeeded
    Success = 0,
    /// Key code is not supported.
    Unsupportedkey = 1,
    /// Requested key code is invalid in the context of the responder's current state.
    Invalidkeyincurrentstate = 2,
}

impl Status {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(Status::Success),
            1 => Some(Status::Unsupportedkey),
            2 => Some(Status::Invalidkeyincurrentstate),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<Status> for u8 {
    fn from(val: Status) -> Self {
        val as u8
    }
}

// Command encoders

/// Encode SendKey command (0x00)
pub fn encode_send_key(key_code: CecKeyCode) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(key_code.to_u8())).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

#[derive(Debug, serde::Serialize)]
pub struct SendKeyResponse {
    pub status: Option<Status>,
}

// Command response decoders

/// Decode SendKeyResponse command response (01)
pub fn decode_send_key_response(inp: &tlv::TlvItemValue) -> anyhow::Result<SendKeyResponse> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(SendKeyResponse {
                status: item.get_int(&[0]).and_then(|v| Status::from_u8(v as u8)),
        })
    } else {
        Err(anyhow::anyhow!("Expected struct fields"))
    }
}

