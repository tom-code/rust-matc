//! Generated Matter TLV encoders and decoders for Bridged Device Basic Information Cluster
//! Cluster ID: 0x0039
//!
//! This file is automatically generated from BridgedDeviceBasicInformationCluster.xml

use crate::tlv;
use anyhow;
use serde_json;


// Enum definitions

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum Color {
    /// Approximately RGB #000000.
    Black = 0,
    /// Approximately RGB #000080.
    Navy = 1,
    /// Approximately RGB #008000.
    Green = 2,
    /// Approximately RGB #008080.
    Teal = 3,
    /// Approximately RGB #800000.
    Maroon = 4,
    /// Approximately RGB #800080.
    Purple = 5,
    /// Approximately RGB #808000.
    Olive = 6,
    /// Approximately RGB #808080.
    Gray = 7,
    /// Approximately RGB #0000FF.
    Blue = 8,
    /// Approximately RGB #00FF00.
    Lime = 9,
    /// Approximately RGB #00FFFF.
    Aqua = 10,
    /// Approximately RGB #FF0000.
    Red = 11,
    /// Approximately RGB #FF00FF.
    Fuchsia = 12,
    /// Approximately RGB #FFFF00.
    Yellow = 13,
    /// Approximately RGB #FFFFFF.
    White = 14,
    /// Typical hardware "Nickel" color.
    Nickel = 15,
    /// Typical hardware "Chrome" color.
    Chrome = 16,
    /// Typical hardware "Brass" color.
    Brass = 17,
    /// Typical hardware "Copper" color.
    Copper = 18,
    /// Typical hardware "Silver" color.
    Silver = 19,
    /// Typical hardware "Gold" color.
    Gold = 20,
}

impl Color {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(Color::Black),
            1 => Some(Color::Navy),
            2 => Some(Color::Green),
            3 => Some(Color::Teal),
            4 => Some(Color::Maroon),
            5 => Some(Color::Purple),
            6 => Some(Color::Olive),
            7 => Some(Color::Gray),
            8 => Some(Color::Blue),
            9 => Some(Color::Lime),
            10 => Some(Color::Aqua),
            11 => Some(Color::Red),
            12 => Some(Color::Fuchsia),
            13 => Some(Color::Yellow),
            14 => Some(Color::White),
            15 => Some(Color::Nickel),
            16 => Some(Color::Chrome),
            17 => Some(Color::Brass),
            18 => Some(Color::Copper),
            19 => Some(Color::Silver),
            20 => Some(Color::Gold),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<Color> for u8 {
    fn from(val: Color) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ProductFinish {
    /// Product has some other finish not listed below.
    Other = 0,
    /// Product has a matte finish.
    Matte = 1,
    /// Product has a satin finish.
    Satin = 2,
    /// Product has a polished or shiny finish.
    Polished = 3,
    /// Product has a rugged finish.
    Rugged = 4,
    /// Product has a fabric finish.
    Fabric = 5,
}

impl ProductFinish {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(ProductFinish::Other),
            1 => Some(ProductFinish::Matte),
            2 => Some(ProductFinish::Satin),
            3 => Some(ProductFinish::Polished),
            4 => Some(ProductFinish::Rugged),
            5 => Some(ProductFinish::Fabric),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<ProductFinish> for u8 {
    fn from(val: ProductFinish) -> Self {
        val as u8
    }
}

// Struct definitions

#[derive(Debug, serde::Serialize)]
pub struct CapabilityMinima {
    pub case_sessions_per_fabric: Option<u16>,
    pub subscriptions_per_fabric: Option<u16>,
}

#[derive(Debug, serde::Serialize)]
pub struct ProductAppearance {
    pub finish: Option<ProductFinish>,
    pub primary_color: Option<Color>,
}

// Command encoders

/// Encode KeepActive command (0x80)
pub fn encode_keep_active(stay_active_duration: u32, timeout_ms: u32) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt32(stay_active_duration)).into(),
        (1, tlv::TlvItemValueEnc::UInt32(timeout_ms)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

// Attribute decoders

/// Decode DataModelRevision attribute (0x0000)
pub fn decode_data_model_revision(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected UInt16"))
    }
}

/// Decode VendorName attribute (0x0001)
pub fn decode_vendor_name(inp: &tlv::TlvItemValue) -> anyhow::Result<String> {
    if let tlv::TlvItemValue::String(v) = inp {
        Ok(v.clone())
    } else {
        Err(anyhow::anyhow!("Expected String"))
    }
}

/// Decode VendorID attribute (0x0002)
pub fn decode_vendor_id(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected UInt16"))
    }
}

/// Decode ProductName attribute (0x0003)
pub fn decode_product_name(inp: &tlv::TlvItemValue) -> anyhow::Result<String> {
    if let tlv::TlvItemValue::String(v) = inp {
        Ok(v.clone())
    } else {
        Err(anyhow::anyhow!("Expected String"))
    }
}

/// Decode ProductID attribute (0x0004)
pub fn decode_product_id(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected UInt16"))
    }
}

/// Decode NodeLabel attribute (0x0005)
pub fn decode_node_label(inp: &tlv::TlvItemValue) -> anyhow::Result<String> {
    if let tlv::TlvItemValue::String(v) = inp {
        Ok(v.clone())
    } else {
        Err(anyhow::anyhow!("Expected String"))
    }
}

/// Decode Location attribute (0x0006)
pub fn decode_location(inp: &tlv::TlvItemValue) -> anyhow::Result<String> {
    if let tlv::TlvItemValue::String(v) = inp {
        Ok(v.clone())
    } else {
        Err(anyhow::anyhow!("Expected String"))
    }
}

/// Decode HardwareVersion attribute (0x0007)
pub fn decode_hardware_version(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected UInt16"))
    }
}

/// Decode HardwareVersionString attribute (0x0008)
pub fn decode_hardware_version_string(inp: &tlv::TlvItemValue) -> anyhow::Result<String> {
    if let tlv::TlvItemValue::String(v) = inp {
        Ok(v.clone())
    } else {
        Err(anyhow::anyhow!("Expected String"))
    }
}

/// Decode SoftwareVersion attribute (0x0009)
pub fn decode_software_version(inp: &tlv::TlvItemValue) -> anyhow::Result<u32> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u32)
    } else {
        Err(anyhow::anyhow!("Expected UInt32"))
    }
}

/// Decode SoftwareVersionString attribute (0x000A)
pub fn decode_software_version_string(inp: &tlv::TlvItemValue) -> anyhow::Result<String> {
    if let tlv::TlvItemValue::String(v) = inp {
        Ok(v.clone())
    } else {
        Err(anyhow::anyhow!("Expected String"))
    }
}

/// Decode ManufacturingDate attribute (0x000B)
pub fn decode_manufacturing_date(inp: &tlv::TlvItemValue) -> anyhow::Result<String> {
    if let tlv::TlvItemValue::String(v) = inp {
        Ok(v.clone())
    } else {
        Err(anyhow::anyhow!("Expected String"))
    }
}

/// Decode PartNumber attribute (0x000C)
pub fn decode_part_number(inp: &tlv::TlvItemValue) -> anyhow::Result<String> {
    if let tlv::TlvItemValue::String(v) = inp {
        Ok(v.clone())
    } else {
        Err(anyhow::anyhow!("Expected String"))
    }
}

/// Decode ProductURL attribute (0x000D)
pub fn decode_product_url(inp: &tlv::TlvItemValue) -> anyhow::Result<String> {
    if let tlv::TlvItemValue::String(v) = inp {
        Ok(v.clone())
    } else {
        Err(anyhow::anyhow!("Expected String"))
    }
}

/// Decode ProductLabel attribute (0x000E)
pub fn decode_product_label(inp: &tlv::TlvItemValue) -> anyhow::Result<String> {
    if let tlv::TlvItemValue::String(v) = inp {
        Ok(v.clone())
    } else {
        Err(anyhow::anyhow!("Expected String"))
    }
}

/// Decode SerialNumber attribute (0x000F)
pub fn decode_serial_number(inp: &tlv::TlvItemValue) -> anyhow::Result<String> {
    if let tlv::TlvItemValue::String(v) = inp {
        Ok(v.clone())
    } else {
        Err(anyhow::anyhow!("Expected String"))
    }
}

/// Decode LocalConfigDisabled attribute (0x0010)
pub fn decode_local_config_disabled(inp: &tlv::TlvItemValue) -> anyhow::Result<bool> {
    if let tlv::TlvItemValue::Bool(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected Bool"))
    }
}

/// Decode Reachable attribute (0x0011)
pub fn decode_reachable(inp: &tlv::TlvItemValue) -> anyhow::Result<bool> {
    if let tlv::TlvItemValue::Bool(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected Bool"))
    }
}

/// Decode UniqueID attribute (0x0012)
pub fn decode_unique_id(inp: &tlv::TlvItemValue) -> anyhow::Result<String> {
    if let tlv::TlvItemValue::String(v) = inp {
        Ok(v.clone())
    } else {
        Err(anyhow::anyhow!("Expected String"))
    }
}

/// Decode CapabilityMinima attribute (0x0013)
pub fn decode_capability_minima(inp: &tlv::TlvItemValue) -> anyhow::Result<CapabilityMinima> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        // Struct with fields
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(CapabilityMinima {
                case_sessions_per_fabric: item.get_int(&[0]).map(|v| v as u16),
                subscriptions_per_fabric: item.get_int(&[1]).map(|v| v as u16),
        })
    } else {
        Err(anyhow::anyhow!("Expected struct fields"))
    }
}

/// Decode ProductAppearance attribute (0x0014)
pub fn decode_product_appearance(inp: &tlv::TlvItemValue) -> anyhow::Result<ProductAppearance> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        // Struct with fields
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(ProductAppearance {
                finish: item.get_int(&[0]).and_then(|v| ProductFinish::from_u8(v as u8)),
                primary_color: item.get_int(&[1]).and_then(|v| Color::from_u8(v as u8)),
        })
    } else {
        Err(anyhow::anyhow!("Expected struct fields"))
    }
}

/// Decode SpecificationVersion attribute (0x0015)
pub fn decode_specification_version(inp: &tlv::TlvItemValue) -> anyhow::Result<u32> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u32)
    } else {
        Err(anyhow::anyhow!("Expected UInt32"))
    }
}

/// Decode MaxPathsPerInvoke attribute (0x0016)
pub fn decode_max_paths_per_invoke(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected UInt16"))
    }
}

/// Decode ConfigurationVersion attribute (0x0018)
pub fn decode_configuration_version(inp: &tlv::TlvItemValue) -> anyhow::Result<u32> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u32)
    } else {
        Err(anyhow::anyhow!("Expected UInt32"))
    }
}


// JSON dispatcher function

/// Decode attribute value and return as JSON string
/// 
/// # Parameters
/// * `cluster_id` - The cluster identifier
/// * `attribute_id` - The attribute identifier
/// * `tlv_value` - The TLV value to decode
/// 
/// # Returns
/// JSON string representation of the decoded value or error
pub fn decode_attribute_json(cluster_id: u32, attribute_id: u32, tlv_value: &crate::tlv::TlvItemValue) -> String {
    // Verify this is the correct cluster
    if cluster_id != 0x0039 {
        return format!("{{\"error\": \"Invalid cluster ID. Expected 0x0039, got {}\"}}", cluster_id);
    }
    
    match attribute_id {
        0x0000 => {
            match decode_data_model_revision(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0001 => {
            match decode_vendor_name(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0002 => {
            match decode_vendor_id(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0003 => {
            match decode_product_name(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0004 => {
            match decode_product_id(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0005 => {
            match decode_node_label(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0006 => {
            match decode_location(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0007 => {
            match decode_hardware_version(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0008 => {
            match decode_hardware_version_string(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0009 => {
            match decode_software_version(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000A => {
            match decode_software_version_string(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000B => {
            match decode_manufacturing_date(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000C => {
            match decode_part_number(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000D => {
            match decode_product_url(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000E => {
            match decode_product_label(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000F => {
            match decode_serial_number(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0010 => {
            match decode_local_config_disabled(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0011 => {
            match decode_reachable(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0012 => {
            match decode_unique_id(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0013 => {
            match decode_capability_minima(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0014 => {
            match decode_product_appearance(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0015 => {
            match decode_specification_version(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0016 => {
            match decode_max_paths_per_invoke(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0018 => {
            match decode_configuration_version(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        _ => format!("{{\"error\": \"Unknown attribute ID: {}\"}}", attribute_id),
    }
}

/// Get list of all attributes supported by this cluster
/// 
/// # Returns
/// Vector of tuples containing (attribute_id, attribute_name)
pub fn get_attribute_list() -> Vec<(u32, &'static str)> {
    vec![
        (0x0000, "DataModelRevision"),
        (0x0001, "VendorName"),
        (0x0002, "VendorID"),
        (0x0003, "ProductName"),
        (0x0004, "ProductID"),
        (0x0005, "NodeLabel"),
        (0x0006, "Location"),
        (0x0007, "HardwareVersion"),
        (0x0008, "HardwareVersionString"),
        (0x0009, "SoftwareVersion"),
        (0x000A, "SoftwareVersionString"),
        (0x000B, "ManufacturingDate"),
        (0x000C, "PartNumber"),
        (0x000D, "ProductURL"),
        (0x000E, "ProductLabel"),
        (0x000F, "SerialNumber"),
        (0x0010, "LocalConfigDisabled"),
        (0x0011, "Reachable"),
        (0x0012, "UniqueID"),
        (0x0013, "CapabilityMinima"),
        (0x0014, "ProductAppearance"),
        (0x0015, "SpecificationVersion"),
        (0x0016, "MaxPathsPerInvoke"),
        (0x0018, "ConfigurationVersion"),
    ]
}

