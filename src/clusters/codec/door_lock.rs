//! Generated Matter TLV encoders and decoders for Door Lock Cluster
//! Cluster ID: 0x0101
//! 
//! This file is automatically generated from DoorLock.xml

use crate::tlv;
use anyhow;
use serde_json;


// Struct definitions

#[derive(Debug, serde::Serialize)]
pub struct Credential {
    pub credential_type: Option<u8>,
    pub credential_index: Option<u16>,
}

// Command encoders

/// Encode LockDoor command (0x00)
pub fn encode_lock_door(pin_code: Vec<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::OctetString(pin_code)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode UnlockDoor command (0x01)
pub fn encode_unlock_door(pin_code: Vec<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::OctetString(pin_code)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode UnlockWithTimeout command (0x03)
pub fn encode_unlock_with_timeout(timeout: u16, pin_code: Vec<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(timeout)).into(),
        (1, tlv::TlvItemValueEnc::OctetString(pin_code)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetPINCode command (0x05)
pub fn encode_set_pin_code(user_id: u16, user_status: Option<u8>, user_type: Option<u8>, pin: Vec<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(user_id)).into(),
        (1, tlv::TlvItemValueEnc::UInt8(user_status.unwrap_or(0))).into(),
        (2, tlv::TlvItemValueEnc::UInt8(user_type.unwrap_or(0))).into(),
        (3, tlv::TlvItemValueEnc::OctetString(pin)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode GetPINCode command (0x06)
pub fn encode_get_pin_code(user_id: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(user_id)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode ClearPINCode command (0x07)
pub fn encode_clear_pin_code(pin_slot_index: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(pin_slot_index)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetUserStatus command (0x09)
pub fn encode_set_user_status(user_id: u16, user_status: u8) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(user_id)).into(),
        (1, tlv::TlvItemValueEnc::UInt8(user_status)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode GetUserStatus command (0x0A)
pub fn encode_get_user_status(user_id: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(user_id)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetWeekDaySchedule command (0x0B)
pub fn encode_set_week_day_schedule(week_day_index: u8, user_index: u16, days_mask: u8, start_hour: u8, start_minute: u8, end_hour: u8, end_minute: u8) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(week_day_index)).into(),
        (1, tlv::TlvItemValueEnc::UInt16(user_index)).into(),
        (2, tlv::TlvItemValueEnc::UInt8(days_mask)).into(),
        (3, tlv::TlvItemValueEnc::UInt8(start_hour)).into(),
        (4, tlv::TlvItemValueEnc::UInt8(start_minute)).into(),
        (5, tlv::TlvItemValueEnc::UInt8(end_hour)).into(),
        (6, tlv::TlvItemValueEnc::UInt8(end_minute)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode GetWeekDaySchedule command (0x0C)
pub fn encode_get_week_day_schedule(week_day_index: u8, user_index: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(week_day_index)).into(),
        (1, tlv::TlvItemValueEnc::UInt16(user_index)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode ClearWeekDaySchedule command (0x0D)
pub fn encode_clear_week_day_schedule(week_day_index: u8, user_index: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(week_day_index)).into(),
        (1, tlv::TlvItemValueEnc::UInt16(user_index)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetYearDaySchedule command (0x0E)
pub fn encode_set_year_day_schedule(year_day_index: u8, user_index: u16, local_start_time: u64, local_end_time: u64) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(year_day_index)).into(),
        (1, tlv::TlvItemValueEnc::UInt16(user_index)).into(),
        (2, tlv::TlvItemValueEnc::UInt64(local_start_time)).into(),
        (3, tlv::TlvItemValueEnc::UInt64(local_end_time)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode GetYearDaySchedule command (0x0F)
pub fn encode_get_year_day_schedule(year_day_index: u8, user_index: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(year_day_index)).into(),
        (1, tlv::TlvItemValueEnc::UInt16(user_index)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode ClearYearDaySchedule command (0x10)
pub fn encode_clear_year_day_schedule(year_day_index: u8, user_index: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(year_day_index)).into(),
        (1, tlv::TlvItemValueEnc::UInt16(user_index)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetHolidaySchedule command (0x11)
pub fn encode_set_holiday_schedule(holiday_index: u8, local_start_time: u64, local_end_time: u64, operating_mode: u8) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(holiday_index)).into(),
        (1, tlv::TlvItemValueEnc::UInt64(local_start_time)).into(),
        (2, tlv::TlvItemValueEnc::UInt64(local_end_time)).into(),
        (3, tlv::TlvItemValueEnc::UInt8(operating_mode)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode GetHolidaySchedule command (0x12)
pub fn encode_get_holiday_schedule(holiday_index: u8) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(holiday_index)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode ClearHolidaySchedule command (0x13)
pub fn encode_clear_holiday_schedule(holiday_index: u8) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(holiday_index)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetUserType command (0x14)
pub fn encode_set_user_type(user_id: u16, user_type: u8) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(user_id)).into(),
        (1, tlv::TlvItemValueEnc::UInt8(user_type)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode GetUserType command (0x15)
pub fn encode_get_user_type(user_id: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(user_id)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetRFIDCode command (0x16)
pub fn encode_set_rfid_code(user_id: u16, user_status: Option<u8>, user_type: Option<u8>, rfid_code: Vec<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(user_id)).into(),
        (1, tlv::TlvItemValueEnc::UInt8(user_status.unwrap_or(0))).into(),
        (2, tlv::TlvItemValueEnc::UInt8(user_type.unwrap_or(0))).into(),
        (3, tlv::TlvItemValueEnc::OctetString(rfid_code)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode GetRFIDCode command (0x17)
pub fn encode_get_rfid_code(user_id: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(user_id)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode ClearRFIDCode command (0x18)
pub fn encode_clear_rfid_code(rfid_slot_index: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(rfid_slot_index)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetUser command (0x1A)
pub fn encode_set_user(operation_type: u8, user_index: u16, user_name: Option<String>, user_unique_id: Option<u32>, user_status: Option<u8>, user_type: Option<u8>, credential_rule: Option<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(operation_type)).into(),
        (1, tlv::TlvItemValueEnc::UInt16(user_index)).into(),
        (2, tlv::TlvItemValueEnc::String(user_name.unwrap_or("".to_string()))).into(),
        (3, tlv::TlvItemValueEnc::UInt32(user_unique_id.unwrap_or(0))).into(),
        (4, tlv::TlvItemValueEnc::UInt8(user_status.unwrap_or(0))).into(),
        (5, tlv::TlvItemValueEnc::UInt8(user_type.unwrap_or(0))).into(),
        (6, tlv::TlvItemValueEnc::UInt8(credential_rule.unwrap_or(0))).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode GetUser command (0x1B)
pub fn encode_get_user(user_index: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(user_index)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode ClearUser command (0x1D)
pub fn encode_clear_user(user_index: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(user_index)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetCredential command (0x22)
pub fn encode_set_credential(operation_type: u8, credential: u8, credential_data: Vec<u8>, user_index: Option<u16>, user_status: Option<u8>, user_type: Option<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(operation_type)).into(),
        (1, tlv::TlvItemValueEnc::UInt8(credential)).into(),
        (2, tlv::TlvItemValueEnc::OctetString(credential_data)).into(),
        (3, tlv::TlvItemValueEnc::UInt16(user_index.unwrap_or(0))).into(),
        (4, tlv::TlvItemValueEnc::UInt8(user_status.unwrap_or(0))).into(),
        (5, tlv::TlvItemValueEnc::UInt8(user_type.unwrap_or(0))).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode GetCredentialStatus command (0x24)
pub fn encode_get_credential_status(credential: u8) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(credential)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode ClearCredential command (0x26)
pub fn encode_clear_credential(credential: Option<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(credential.unwrap_or(0))).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode UnboltDoor command (0x27)
pub fn encode_unbolt_door(pin_code: Vec<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::OctetString(pin_code)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetAliroReaderConfig command (0x28)
pub fn encode_set_aliro_reader_config(signing_key: Vec<u8>, verification_key: Vec<u8>, group_identifier: Vec<u8>, group_resolving_key: Vec<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::OctetString(signing_key)).into(),
        (1, tlv::TlvItemValueEnc::OctetString(verification_key)).into(),
        (2, tlv::TlvItemValueEnc::OctetString(group_identifier)).into(),
        (3, tlv::TlvItemValueEnc::OctetString(group_resolving_key)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

// Attribute decoders

/// Decode LockState attribute (0x0000)
pub fn decode_lock_state(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode LockType attribute (0x0001)
pub fn decode_lock_type(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode ActuatorEnabled attribute (0x0002)
pub fn decode_actuator_enabled(inp: &tlv::TlvItemValue) -> anyhow::Result<bool> {
    if let tlv::TlvItemValue::Bool(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected Bool"))
    }
}

/// Decode DoorState attribute (0x0003)
pub fn decode_door_state(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode DoorOpenEvents attribute (0x0004)
pub fn decode_door_open_events(inp: &tlv::TlvItemValue) -> anyhow::Result<u32> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u32)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode DoorClosedEvents attribute (0x0005)
pub fn decode_door_closed_events(inp: &tlv::TlvItemValue) -> anyhow::Result<u32> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u32)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode OpenPeriod attribute (0x0006)
pub fn decode_open_period(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode NumberOfTotalUsersSupported attribute (0x0011)
pub fn decode_number_of_total_users_supported(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode NumberOfPINUsersSupported attribute (0x0012)
pub fn decode_number_of_pin_users_supported(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode NumberOfRFIDUsersSupported attribute (0x0013)
pub fn decode_number_of_rfid_users_supported(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode NumberOfWeekDaySchedulesSupportedPerUser attribute (0x0014)
pub fn decode_number_of_week_day_schedules_supported_per_user(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode NumberOfYearDaySchedulesSupportedPerUser attribute (0x0015)
pub fn decode_number_of_year_day_schedules_supported_per_user(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode NumberOfHolidaySchedulesSupported attribute (0x0016)
pub fn decode_number_of_holiday_schedules_supported(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode MaxPINCodeLength attribute (0x0017)
pub fn decode_max_pin_code_length(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode MinPINCodeLength attribute (0x0018)
pub fn decode_min_pin_code_length(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode MaxRFIDCodeLength attribute (0x0019)
pub fn decode_max_rfid_code_length(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode MinRFIDCodeLength attribute (0x001A)
pub fn decode_min_rfid_code_length(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode CredentialRulesSupport attribute (0x001B)
pub fn decode_credential_rules_support(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode NumberOfCredentialsSupportedPerUser attribute (0x001C)
pub fn decode_number_of_credentials_supported_per_user(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode Language attribute (0x0021)
pub fn decode_language(inp: &tlv::TlvItemValue) -> anyhow::Result<String> {
    if let tlv::TlvItemValue::String(v) = inp {
        Ok(v.clone())
    } else {
        Err(anyhow::anyhow!("Expected String"))
    }
}

/// Decode LEDSettings attribute (0x0022)
pub fn decode_led_settings(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode AutoRelockTime attribute (0x0023)
pub fn decode_auto_relock_time(inp: &tlv::TlvItemValue) -> anyhow::Result<u32> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u32)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode SoundVolume attribute (0x0024)
pub fn decode_sound_volume(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode OperatingMode attribute (0x0025)
pub fn decode_operating_mode(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode SupportedOperatingModes attribute (0x0026)
pub fn decode_supported_operating_modes(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode DefaultConfigurationRegister attribute (0x0027)
pub fn decode_default_configuration_register(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode EnableLocalProgramming attribute (0x0028)
pub fn decode_enable_local_programming(inp: &tlv::TlvItemValue) -> anyhow::Result<bool> {
    if let tlv::TlvItemValue::Bool(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected Bool"))
    }
}

/// Decode EnableOneTouchLocking attribute (0x0029)
pub fn decode_enable_one_touch_locking(inp: &tlv::TlvItemValue) -> anyhow::Result<bool> {
    if let tlv::TlvItemValue::Bool(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected Bool"))
    }
}

/// Decode EnableInsideStatusLED attribute (0x002A)
pub fn decode_enable_inside_status_led(inp: &tlv::TlvItemValue) -> anyhow::Result<bool> {
    if let tlv::TlvItemValue::Bool(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected Bool"))
    }
}

/// Decode EnablePrivacyModeButton attribute (0x002B)
pub fn decode_enable_privacy_mode_button(inp: &tlv::TlvItemValue) -> anyhow::Result<bool> {
    if let tlv::TlvItemValue::Bool(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected Bool"))
    }
}

/// Decode LocalProgrammingFeatures attribute (0x002C)
pub fn decode_local_programming_features(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode WrongCodeEntryLimit attribute (0x0030)
pub fn decode_wrong_code_entry_limit(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode UserCodeTemporaryDisableTime attribute (0x0031)
pub fn decode_user_code_temporary_disable_time(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode SendPINOverTheAir attribute (0x0032)
pub fn decode_send_pin_over_the_air(inp: &tlv::TlvItemValue) -> anyhow::Result<bool> {
    if let tlv::TlvItemValue::Bool(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected Bool"))
    }
}

/// Decode RequirePINforRemoteOperation attribute (0x0033)
pub fn decode_require_pinfor_remote_operation(inp: &tlv::TlvItemValue) -> anyhow::Result<bool> {
    if let tlv::TlvItemValue::Bool(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected Bool"))
    }
}

/// Decode SecurityLevel attribute (0x0034)
pub fn decode_security_level(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode ExpiringUserTimeout attribute (0x0035)
pub fn decode_expiring_user_timeout(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode AliroReaderVerificationKey attribute (0x0080)
pub fn decode_aliro_reader_verification_key(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<Vec<u8>>> {
    if let tlv::TlvItemValue::OctetString(v) = inp {
        Ok(Some(v.clone()))
    } else {
        Ok(None)
    }
}

/// Decode AliroReaderGroupIdentifier attribute (0x0081)
pub fn decode_aliro_reader_group_identifier(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<Vec<u8>>> {
    if let tlv::TlvItemValue::OctetString(v) = inp {
        Ok(Some(v.clone()))
    } else {
        Ok(None)
    }
}

/// Decode AliroReaderGroupSubIdentifier attribute (0x0082)
pub fn decode_aliro_reader_group_sub_identifier(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<u8>> {
    if let tlv::TlvItemValue::OctetString(v) = inp {
        Ok(v.clone())
    } else {
        Err(anyhow::anyhow!("Expected OctetString"))
    }
}

/// Decode AliroExpeditedTransactionSupportedProtocolVersions attribute (0x0083)
pub fn decode_aliro_expedited_transaction_supported_protocol_versions(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<Vec<u8>>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            if let tlv::TlvItemValue::OctetString(o) = &item.value {
                res.push(o.clone());
            }
        }
    }
    Ok(res)
}

/// Decode AliroGroupResolvingKey attribute (0x0084)
pub fn decode_aliro_group_resolving_key(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<Vec<u8>>> {
    if let tlv::TlvItemValue::OctetString(v) = inp {
        Ok(Some(v.clone()))
    } else {
        Ok(None)
    }
}

/// Decode AliroSupportedBLEUWBProtocolVersions attribute (0x0085)
pub fn decode_aliro_supported_bleuwb_protocol_versions(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<Vec<u8>>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            if let tlv::TlvItemValue::OctetString(o) = &item.value {
                res.push(o.clone());
            }
        }
    }
    Ok(res)
}

/// Decode AliroBLEAdvertisingVersion attribute (0x0086)
pub fn decode_aliro_ble_advertising_version(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode NumberOfAliroCredentialIssuerKeysSupported attribute (0x0087)
pub fn decode_number_of_aliro_credential_issuer_keys_supported(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode NumberOfAliroEndpointKeysSupported attribute (0x0088)
pub fn decode_number_of_aliro_endpoint_keys_supported(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}


// JSON dispatcher function

/// Decode attribute value and return as JSON string
/// 
/// # Parameters
/// * `cluster_id` - The cluster identifier
/// * `attribute_id` - The attribute identifier
/// * `tlv_value` - The TLV value to decode
/// 
/// # Returns
/// JSON string representation of the decoded value or error
pub fn decode_attribute_json(cluster_id: u32, attribute_id: u32, tlv_value: &crate::tlv::TlvItemValue) -> String {
    // Verify this is the correct cluster
    if cluster_id != 0x0101 {
        return format!("{{\"error\": \"Invalid cluster ID. Expected 0x0101, got {}\"}}", cluster_id);
    }
    
    match attribute_id {
        0x0000 => {
            match decode_lock_state(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0001 => {
            match decode_lock_type(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0002 => {
            match decode_actuator_enabled(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0003 => {
            match decode_door_state(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0004 => {
            match decode_door_open_events(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0005 => {
            match decode_door_closed_events(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0006 => {
            match decode_open_period(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0011 => {
            match decode_number_of_total_users_supported(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0012 => {
            match decode_number_of_pin_users_supported(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0013 => {
            match decode_number_of_rfid_users_supported(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0014 => {
            match decode_number_of_week_day_schedules_supported_per_user(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0015 => {
            match decode_number_of_year_day_schedules_supported_per_user(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0016 => {
            match decode_number_of_holiday_schedules_supported(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0017 => {
            match decode_max_pin_code_length(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0018 => {
            match decode_min_pin_code_length(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0019 => {
            match decode_max_rfid_code_length(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x001A => {
            match decode_min_rfid_code_length(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x001B => {
            match decode_credential_rules_support(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x001C => {
            match decode_number_of_credentials_supported_per_user(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0021 => {
            match decode_language(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0022 => {
            match decode_led_settings(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0023 => {
            match decode_auto_relock_time(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0024 => {
            match decode_sound_volume(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0025 => {
            match decode_operating_mode(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0026 => {
            match decode_supported_operating_modes(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0027 => {
            match decode_default_configuration_register(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0028 => {
            match decode_enable_local_programming(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0029 => {
            match decode_enable_one_touch_locking(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x002A => {
            match decode_enable_inside_status_led(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x002B => {
            match decode_enable_privacy_mode_button(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x002C => {
            match decode_local_programming_features(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0030 => {
            match decode_wrong_code_entry_limit(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0031 => {
            match decode_user_code_temporary_disable_time(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0032 => {
            match decode_send_pin_over_the_air(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0033 => {
            match decode_require_pinfor_remote_operation(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0034 => {
            match decode_security_level(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0035 => {
            match decode_expiring_user_timeout(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0080 => {
            match decode_aliro_reader_verification_key(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0081 => {
            match decode_aliro_reader_group_identifier(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0082 => {
            match decode_aliro_reader_group_sub_identifier(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0083 => {
            match decode_aliro_expedited_transaction_supported_protocol_versions(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0084 => {
            match decode_aliro_group_resolving_key(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0085 => {
            match decode_aliro_supported_bleuwb_protocol_versions(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0086 => {
            match decode_aliro_ble_advertising_version(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0087 => {
            match decode_number_of_aliro_credential_issuer_keys_supported(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0088 => {
            match decode_number_of_aliro_endpoint_keys_supported(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        _ => format!("{{\"error\": \"Unknown attribute ID: {}\"}}", attribute_id),
    }
}

/// Get list of all attributes supported by this cluster
/// 
/// # Returns
/// Vector of tuples containing (attribute_id, attribute_name)
pub fn get_attribute_list() -> Vec<(u32, &'static str)> {
    vec![
        (0x0000, "LockState"),
        (0x0001, "LockType"),
        (0x0002, "ActuatorEnabled"),
        (0x0003, "DoorState"),
        (0x0004, "DoorOpenEvents"),
        (0x0005, "DoorClosedEvents"),
        (0x0006, "OpenPeriod"),
        (0x0011, "NumberOfTotalUsersSupported"),
        (0x0012, "NumberOfPINUsersSupported"),
        (0x0013, "NumberOfRFIDUsersSupported"),
        (0x0014, "NumberOfWeekDaySchedulesSupportedPerUser"),
        (0x0015, "NumberOfYearDaySchedulesSupportedPerUser"),
        (0x0016, "NumberOfHolidaySchedulesSupported"),
        (0x0017, "MaxPINCodeLength"),
        (0x0018, "MinPINCodeLength"),
        (0x0019, "MaxRFIDCodeLength"),
        (0x001A, "MinRFIDCodeLength"),
        (0x001B, "CredentialRulesSupport"),
        (0x001C, "NumberOfCredentialsSupportedPerUser"),
        (0x0021, "Language"),
        (0x0022, "LEDSettings"),
        (0x0023, "AutoRelockTime"),
        (0x0024, "SoundVolume"),
        (0x0025, "OperatingMode"),
        (0x0026, "SupportedOperatingModes"),
        (0x0027, "DefaultConfigurationRegister"),
        (0x0028, "EnableLocalProgramming"),
        (0x0029, "EnableOneTouchLocking"),
        (0x002A, "EnableInsideStatusLED"),
        (0x002B, "EnablePrivacyModeButton"),
        (0x002C, "LocalProgrammingFeatures"),
        (0x0030, "WrongCodeEntryLimit"),
        (0x0031, "UserCodeTemporaryDisableTime"),
        (0x0032, "SendPINOverTheAir"),
        (0x0033, "RequirePINforRemoteOperation"),
        (0x0034, "SecurityLevel"),
        (0x0035, "ExpiringUserTimeout"),
        (0x0080, "AliroReaderVerificationKey"),
        (0x0081, "AliroReaderGroupIdentifier"),
        (0x0082, "AliroReaderGroupSubIdentifier"),
        (0x0083, "AliroExpeditedTransactionSupportedProtocolVersions"),
        (0x0084, "AliroGroupResolvingKey"),
        (0x0085, "AliroSupportedBLEUWBProtocolVersions"),
        (0x0086, "AliroBLEAdvertisingVersion"),
        (0x0087, "NumberOfAliroCredentialIssuerKeysSupported"),
        (0x0088, "NumberOfAliroEndpointKeysSupported"),
    ]
}

