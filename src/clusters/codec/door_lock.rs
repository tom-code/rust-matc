//! Generated Matter TLV encoders and decoders for Door Lock Cluster
//! Cluster ID: 0x0101
//!
//! This file is automatically generated from DoorLock.xml

use crate::tlv;
use anyhow;
use serde_json;


// Enum definitions

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum AlarmCode {
    /// Locking Mechanism Jammed
    Lockjammed = 0,
    /// Lock Reset to Factory Defaults
    Lockfactoryreset = 1,
    /// Lock Radio Power Cycled
    Lockradiopowercycled = 3,
    /// Tamper Alarm - wrong code entry limit
    Wrongcodeentrylimit = 4,
    /// Tamper Alarm - front escutcheon removed from main
    Frontesceutcheonremoved = 5,
    /// Forced Door Open under Door Locked Condition
    Doorforcedopen = 6,
    /// Door ajar
    Doorajar = 7,
    /// Force User SOS alarm
    Forceduser = 8,
}

impl AlarmCode {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(AlarmCode::Lockjammed),
            1 => Some(AlarmCode::Lockfactoryreset),
            3 => Some(AlarmCode::Lockradiopowercycled),
            4 => Some(AlarmCode::Wrongcodeentrylimit),
            5 => Some(AlarmCode::Frontesceutcheonremoved),
            6 => Some(AlarmCode::Doorforcedopen),
            7 => Some(AlarmCode::Doorajar),
            8 => Some(AlarmCode::Forceduser),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<AlarmCode> for u8 {
    fn from(val: AlarmCode) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum CredentialRule {
    /// Only one credential is required for lock operation
    Single = 0,
    /// Any two credentials are required for lock operation
    Dual = 1,
    /// Any three credentials are required for lock operation
    Tri = 2,
}

impl CredentialRule {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(CredentialRule::Single),
            1 => Some(CredentialRule::Dual),
            2 => Some(CredentialRule::Tri),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<CredentialRule> for u8 {
    fn from(val: CredentialRule) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum CredentialType {
    /// Programming PIN code credential type
    Programmingpin = 0,
    /// PIN code credential type
    Pin = 1,
    /// RFID identifier credential type
    Rfid = 2,
    /// Fingerprint identifier credential type
    Fingerprint = 3,
    /// Finger vein identifier credential type
    Fingervein = 4,
    /// Face identifier credential type
    Face = 5,
    /// A Credential Issuer public key as defined in [Aliro&#93;
    Alirocredentialissuerkey = 6,
    /// An Endpoint public key as defined in [Aliro&#93; which can be evicted if space is needed for another endpoint key
    Aliroevictableendpointkey = 7,
    /// An Endpoint public key as defined in [Aliro&#93; which cannot be evicted if space is needed for another endpoint key
    Alirononevictableendpointkey = 8,
}

impl CredentialType {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(CredentialType::Programmingpin),
            1 => Some(CredentialType::Pin),
            2 => Some(CredentialType::Rfid),
            3 => Some(CredentialType::Fingerprint),
            4 => Some(CredentialType::Fingervein),
            5 => Some(CredentialType::Face),
            6 => Some(CredentialType::Alirocredentialissuerkey),
            7 => Some(CredentialType::Aliroevictableendpointkey),
            8 => Some(CredentialType::Alirononevictableendpointkey),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<CredentialType> for u8 {
    fn from(val: CredentialType) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum DataOperationType {
    /// Data is being added or was added
    Add = 0,
    /// Data is being cleared or was cleared
    Clear = 1,
    /// Data is being modified or was modified
    Modify = 2,
}

impl DataOperationType {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(DataOperationType::Add),
            1 => Some(DataOperationType::Clear),
            2 => Some(DataOperationType::Modify),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<DataOperationType> for u8 {
    fn from(val: DataOperationType) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum DoorState {
    /// Door state is open
    Dooropen = 0,
    /// Door state is closed
    Doorclosed = 1,
    /// Door state is jammed
    Doorjammed = 2,
    /// Door state is currently forced open
    Doorforcedopen = 3,
    /// Door state is invalid for unspecified reason
    Doorunspecifiederror = 4,
    /// Door state is ajar
    Doorajar = 5,
}

impl DoorState {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(DoorState::Dooropen),
            1 => Some(DoorState::Doorclosed),
            2 => Some(DoorState::Doorjammed),
            3 => Some(DoorState::Doorforcedopen),
            4 => Some(DoorState::Doorunspecifiederror),
            5 => Some(DoorState::Doorajar),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<DoorState> for u8 {
    fn from(val: DoorState) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum EventType {
    /// Event type is operation
    Operation = 0,
    /// Event type is programming
    Programming = 1,
    /// Event type is alarm
    Alarm = 2,
}

impl EventType {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(EventType::Operation),
            1 => Some(EventType::Programming),
            2 => Some(EventType::Alarm),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<EventType> for u8 {
    fn from(val: EventType) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum LEDSetting {
    /// Never use LED for signalization
    Noledsignal = 0,
    /// Use LED signalization except for access allowed events
    Noledsignalaccessallowed = 1,
    /// Use LED signalization for all events
    Ledsignalall = 2,
}

impl LEDSetting {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(LEDSetting::Noledsignal),
            1 => Some(LEDSetting::Noledsignalaccessallowed),
            2 => Some(LEDSetting::Ledsignalall),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<LEDSetting> for u8 {
    fn from(val: LEDSetting) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum LockDataType {
    /// Unspecified or manufacturer specific lock user data added, cleared, or modified.
    Unspecified = 0,
    /// Lock programming PIN code was added, cleared, or modified.
    Programmingcode = 1,
    /// Lock user index was added, cleared, or modified.
    Userindex = 2,
    /// Lock user week day schedule was added, cleared, or modified.
    Weekdayschedule = 3,
    /// Lock user year day schedule was added, cleared, or modified.
    Yeardayschedule = 4,
    /// Lock holiday schedule was added, cleared, or modified.
    Holidayschedule = 5,
    /// Lock user PIN code was added, cleared, or modified.
    Pin = 6,
    /// Lock user RFID code was added, cleared, or modified.
    Rfid = 7,
    /// Lock user fingerprint was added, cleared, or modified.
    Fingerprint = 8,
    /// Lock user finger-vein information was added, cleared, or modified.
    Fingervein = 9,
    /// Lock user face information was added, cleared, or modified.
    Face = 10,
    /// An Aliro credential issuer key credential was added, cleared, or modified.
    Alirocredentialissuerkey = 11,
    /// An Aliro endpoint key credential which can be evicted credential was added, cleared, or modified.
    Aliroevictableendpointkey = 12,
    /// An Aliro endpoint key credential which cannot be evicted was added, cleared, or modified.
    Alirononevictableendpointkey = 13,
}

impl LockDataType {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(LockDataType::Unspecified),
            1 => Some(LockDataType::Programmingcode),
            2 => Some(LockDataType::Userindex),
            3 => Some(LockDataType::Weekdayschedule),
            4 => Some(LockDataType::Yeardayschedule),
            5 => Some(LockDataType::Holidayschedule),
            6 => Some(LockDataType::Pin),
            7 => Some(LockDataType::Rfid),
            8 => Some(LockDataType::Fingerprint),
            9 => Some(LockDataType::Fingervein),
            10 => Some(LockDataType::Face),
            11 => Some(LockDataType::Alirocredentialissuerkey),
            12 => Some(LockDataType::Aliroevictableendpointkey),
            13 => Some(LockDataType::Alirononevictableendpointkey),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<LockDataType> for u8 {
    fn from(val: LockDataType) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum LockOperationType {
    /// Lock operation
    Lock = 0,
    /// Unlock operation
    Unlock = 1,
    /// Triggered by keypad entry for user with User Type set to Non Access User
    Nonaccessuserevent = 2,
    /// Triggered by using a user with UserType set to Forced User
    Forceduserevent = 3,
    /// Unlatch operation
    Unlatch = 4,
}

impl LockOperationType {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(LockOperationType::Lock),
            1 => Some(LockOperationType::Unlock),
            2 => Some(LockOperationType::Nonaccessuserevent),
            3 => Some(LockOperationType::Forceduserevent),
            4 => Some(LockOperationType::Unlatch),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<LockOperationType> for u8 {
    fn from(val: LockOperationType) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum LockState {
    /// Lock state is not fully locked
    Notfullylocked = 0,
    /// Lock state is fully locked
    Locked = 1,
    /// Lock state is fully unlocked
    Unlocked = 2,
    /// Lock state is fully unlocked and the latch is pulled
    Unlatched = 3,
}

impl LockState {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(LockState::Notfullylocked),
            1 => Some(LockState::Locked),
            2 => Some(LockState::Unlocked),
            3 => Some(LockState::Unlatched),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<LockState> for u8 {
    fn from(val: LockState) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum LockType {
    /// Physical lock type is dead bolt
    Deadbolt = 0,
    /// Physical lock type is magnetic
    Magnetic = 1,
    /// Physical lock type is other
    Other = 2,
    /// Physical lock type is mortise
    Mortise = 3,
    /// Physical lock type is rim
    Rim = 4,
    /// Physical lock type is latch bolt
    Latchbolt = 5,
    /// Physical lock type is cylindrical lock
    Cylindricallock = 6,
    /// Physical lock type is tubular lock
    Tubularlock = 7,
    /// Physical lock type is interconnected lock
    Interconnectedlock = 8,
    /// Physical lock type is dead latch
    Deadlatch = 9,
    /// Physical lock type is door furniture
    Doorfurniture = 10,
    /// Physical lock type is euro cylinder
    Eurocylinder = 11,
}

impl LockType {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(LockType::Deadbolt),
            1 => Some(LockType::Magnetic),
            2 => Some(LockType::Other),
            3 => Some(LockType::Mortise),
            4 => Some(LockType::Rim),
            5 => Some(LockType::Latchbolt),
            6 => Some(LockType::Cylindricallock),
            7 => Some(LockType::Tubularlock),
            8 => Some(LockType::Interconnectedlock),
            9 => Some(LockType::Deadlatch),
            10 => Some(LockType::Doorfurniture),
            11 => Some(LockType::Eurocylinder),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<LockType> for u8 {
    fn from(val: LockType) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum OperatingMode {
    Normal = 0,
    Vacation = 1,
    Privacy = 2,
    Noremotelockunlock = 3,
    Passage = 4,
}

impl OperatingMode {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(OperatingMode::Normal),
            1 => Some(OperatingMode::Vacation),
            2 => Some(OperatingMode::Privacy),
            3 => Some(OperatingMode::Noremotelockunlock),
            4 => Some(OperatingMode::Passage),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<OperatingMode> for u8 {
    fn from(val: OperatingMode) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum OperationError {
    /// Lock/unlock error caused by unknown or unspecified source
    Unspecified = 0,
    /// Lock/unlock error caused by invalid PIN, RFID, fingerprint or other credential
    Invalidcredential = 1,
    /// Lock/unlock error caused by disabled USER or credential
    Disableduserdenied = 2,
    /// Lock/unlock error caused by schedule restriction
    Restricted = 3,
    /// Lock/unlock error caused by insufficient battery power left to safely actuate the lock
    Insufficientbattery = 4,
}

impl OperationError {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(OperationError::Unspecified),
            1 => Some(OperationError::Invalidcredential),
            2 => Some(OperationError::Disableduserdenied),
            3 => Some(OperationError::Restricted),
            4 => Some(OperationError::Insufficientbattery),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<OperationError> for u8 {
    fn from(val: OperationError) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum OperationSource {
    /// Lock/unlock operation came from unspecified source
    Unspecified = 0,
    /// Lock/unlock operation came from manual operation (key, thumbturn, handle, etc).
    Manual = 1,
    /// Lock/unlock operation came from proprietary remote source (e.g. vendor app/cloud)
    Proprietaryremote = 2,
    /// Lock/unlock operation came from keypad
    Keypad = 3,
    /// Lock/unlock operation came from lock automatically (e.g. relock timer)
    Auto = 4,
    /// Lock/unlock operation came from lock button (e.g. one touch or button)
    Button = 5,
    /// Lock/unlock operation came from lock due to a schedule
    Schedule = 6,
    /// Lock/unlock operation came from remote node
    Remote = 7,
    /// Lock/unlock operation came from RFID card
    Rfid = 8,
    /// Lock/unlock operation came from biometric source (e.g. face, fingerprint/fingervein)
    Biometric = 9,
    /// Lock/unlock operation came from an interaction defined in [Aliro&#93;, or user change operation was a step-up credential provisioning as defined in [Aliro&#93;
    Aliro = 10,
}

impl OperationSource {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(OperationSource::Unspecified),
            1 => Some(OperationSource::Manual),
            2 => Some(OperationSource::Proprietaryremote),
            3 => Some(OperationSource::Keypad),
            4 => Some(OperationSource::Auto),
            5 => Some(OperationSource::Button),
            6 => Some(OperationSource::Schedule),
            7 => Some(OperationSource::Remote),
            8 => Some(OperationSource::Rfid),
            9 => Some(OperationSource::Biometric),
            10 => Some(OperationSource::Aliro),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<OperationSource> for u8 {
    fn from(val: OperationSource) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum SoundVolume {
    /// Silent Mode
    Silent = 0,
    /// Low Volume
    Low = 1,
    /// High Volume
    High = 2,
    /// Medium Volume
    Medium = 3,
}

impl SoundVolume {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(SoundVolume::Silent),
            1 => Some(SoundVolume::Low),
            2 => Some(SoundVolume::High),
            3 => Some(SoundVolume::Medium),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<SoundVolume> for u8 {
    fn from(val: SoundVolume) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum StatusCode {
    /// Entry would cause a duplicate credential/ID.
    Duplicate = 2,
    /// Entry would replace an occupied slot.
    Occupied = 3,
}

impl StatusCode {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            2 => Some(StatusCode::Duplicate),
            3 => Some(StatusCode::Occupied),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<StatusCode> for u8 {
    fn from(val: StatusCode) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum UserStatus {
    /// The user ID is available
    Available = 0,
    /// The user ID is occupied and enabled
    Occupiedenabled = 1,
    /// The user ID is occupied and disabled
    Occupieddisabled = 3,
}

impl UserStatus {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(UserStatus::Available),
            1 => Some(UserStatus::Occupiedenabled),
            3 => Some(UserStatus::Occupieddisabled),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<UserStatus> for u8 {
    fn from(val: UserStatus) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum UserType {
    /// The user ID type is unrestricted
    Unrestricteduser = 0,
    /// The user ID type is schedule
    Yeardayscheduleuser = 1,
    /// The user ID type is schedule
    Weekdayscheduleuser = 2,
    /// The user ID type is programming
    Programminguser = 3,
    /// The user ID type is non access
    Nonaccessuser = 4,
    /// The user ID type is forced
    Forceduser = 5,
    /// The user ID type is disposable
    Disposableuser = 6,
    /// The user ID type is expiring
    Expiringuser = 7,
    /// The user ID type is schedule restricted
    Schedulerestricteduser = 8,
    /// The user ID type is remote only
    Remoteonlyuser = 9,
}

impl UserType {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(UserType::Unrestricteduser),
            1 => Some(UserType::Yeardayscheduleuser),
            2 => Some(UserType::Weekdayscheduleuser),
            3 => Some(UserType::Programminguser),
            4 => Some(UserType::Nonaccessuser),
            5 => Some(UserType::Forceduser),
            6 => Some(UserType::Disposableuser),
            7 => Some(UserType::Expiringuser),
            8 => Some(UserType::Schedulerestricteduser),
            9 => Some(UserType::Remoteonlyuser),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<UserType> for u8 {
    fn from(val: UserType) -> Self {
        val as u8
    }
}

// Struct definitions

#[derive(Debug, serde::Serialize)]
pub struct Credential {
    pub credential_type: Option<CredentialType>,
    pub credential_index: Option<u16>,
}

// Command encoders

/// Encode LockDoor command (0x00)
pub fn encode_lock_door(pin_code: Vec<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::OctetString(pin_code)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode UnlockDoor command (0x01)
pub fn encode_unlock_door(pin_code: Vec<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::OctetString(pin_code)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode UnlockWithTimeout command (0x03)
pub fn encode_unlock_with_timeout(timeout: u16, pin_code: Vec<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(timeout)).into(),
        (1, tlv::TlvItemValueEnc::OctetString(pin_code)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetPINCode command (0x05)
pub fn encode_set_pin_code(user_id: u16, user_status: Option<UserStatus>, user_type: Option<UserType>, pin: Vec<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(user_id)).into(),
        (1, tlv::TlvItemValueEnc::UInt8(user_status.map(|e| e.to_u8()).unwrap_or(0))).into(),
        (2, tlv::TlvItemValueEnc::UInt8(user_type.map(|e| e.to_u8()).unwrap_or(0))).into(),
        (3, tlv::TlvItemValueEnc::OctetString(pin)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode GetPINCode command (0x06)
pub fn encode_get_pin_code(user_id: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(user_id)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode ClearPINCode command (0x07)
pub fn encode_clear_pin_code(pin_slot_index: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(pin_slot_index)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetUserStatus command (0x09)
pub fn encode_set_user_status(user_id: u16, user_status: UserStatus) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(user_id)).into(),
        (1, tlv::TlvItemValueEnc::UInt8(user_status.to_u8())).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode GetUserStatus command (0x0A)
pub fn encode_get_user_status(user_id: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(user_id)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetWeekDaySchedule command (0x0B)
pub fn encode_set_week_day_schedule(week_day_index: u8, user_index: u16, days_mask: u8, start_hour: u8, start_minute: u8, end_hour: u8, end_minute: u8) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(week_day_index)).into(),
        (1, tlv::TlvItemValueEnc::UInt16(user_index)).into(),
        (2, tlv::TlvItemValueEnc::UInt8(days_mask)).into(),
        (3, tlv::TlvItemValueEnc::UInt8(start_hour)).into(),
        (4, tlv::TlvItemValueEnc::UInt8(start_minute)).into(),
        (5, tlv::TlvItemValueEnc::UInt8(end_hour)).into(),
        (6, tlv::TlvItemValueEnc::UInt8(end_minute)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode GetWeekDaySchedule command (0x0C)
pub fn encode_get_week_day_schedule(week_day_index: u8, user_index: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(week_day_index)).into(),
        (1, tlv::TlvItemValueEnc::UInt16(user_index)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode ClearWeekDaySchedule command (0x0D)
pub fn encode_clear_week_day_schedule(week_day_index: u8, user_index: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(week_day_index)).into(),
        (1, tlv::TlvItemValueEnc::UInt16(user_index)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetYearDaySchedule command (0x0E)
pub fn encode_set_year_day_schedule(year_day_index: u8, user_index: u16, local_start_time: u64, local_end_time: u64) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(year_day_index)).into(),
        (1, tlv::TlvItemValueEnc::UInt16(user_index)).into(),
        (2, tlv::TlvItemValueEnc::UInt64(local_start_time)).into(),
        (3, tlv::TlvItemValueEnc::UInt64(local_end_time)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode GetYearDaySchedule command (0x0F)
pub fn encode_get_year_day_schedule(year_day_index: u8, user_index: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(year_day_index)).into(),
        (1, tlv::TlvItemValueEnc::UInt16(user_index)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode ClearYearDaySchedule command (0x10)
pub fn encode_clear_year_day_schedule(year_day_index: u8, user_index: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(year_day_index)).into(),
        (1, tlv::TlvItemValueEnc::UInt16(user_index)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetHolidaySchedule command (0x11)
pub fn encode_set_holiday_schedule(holiday_index: u8, local_start_time: u64, local_end_time: u64, operating_mode: OperatingMode) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(holiday_index)).into(),
        (1, tlv::TlvItemValueEnc::UInt64(local_start_time)).into(),
        (2, tlv::TlvItemValueEnc::UInt64(local_end_time)).into(),
        (3, tlv::TlvItemValueEnc::UInt8(operating_mode.to_u8())).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode GetHolidaySchedule command (0x12)
pub fn encode_get_holiday_schedule(holiday_index: u8) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(holiday_index)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode ClearHolidaySchedule command (0x13)
pub fn encode_clear_holiday_schedule(holiday_index: u8) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(holiday_index)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetUserType command (0x14)
pub fn encode_set_user_type(user_id: u16, user_type: UserType) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(user_id)).into(),
        (1, tlv::TlvItemValueEnc::UInt8(user_type.to_u8())).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode GetUserType command (0x15)
pub fn encode_get_user_type(user_id: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(user_id)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetRFIDCode command (0x16)
pub fn encode_set_rfid_code(user_id: u16, user_status: Option<UserStatus>, user_type: Option<UserType>, rfid_code: Vec<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(user_id)).into(),
        (1, tlv::TlvItemValueEnc::UInt8(user_status.map(|e| e.to_u8()).unwrap_or(0))).into(),
        (2, tlv::TlvItemValueEnc::UInt8(user_type.map(|e| e.to_u8()).unwrap_or(0))).into(),
        (3, tlv::TlvItemValueEnc::OctetString(rfid_code)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode GetRFIDCode command (0x17)
pub fn encode_get_rfid_code(user_id: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(user_id)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode ClearRFIDCode command (0x18)
pub fn encode_clear_rfid_code(rfid_slot_index: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(rfid_slot_index)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetUser command (0x1A)
pub fn encode_set_user(operation_type: DataOperationType, user_index: u16, user_name: Option<String>, user_unique_id: Option<u32>, user_status: Option<UserStatus>, user_type: Option<UserType>, credential_rule: Option<CredentialRule>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(operation_type.to_u8())).into(),
        (1, tlv::TlvItemValueEnc::UInt16(user_index)).into(),
        (2, tlv::TlvItemValueEnc::String(user_name.unwrap_or("".to_string()))).into(),
        (3, tlv::TlvItemValueEnc::UInt32(user_unique_id.unwrap_or(0))).into(),
        (4, tlv::TlvItemValueEnc::UInt8(user_status.map(|e| e.to_u8()).unwrap_or(0))).into(),
        (5, tlv::TlvItemValueEnc::UInt8(user_type.map(|e| e.to_u8()).unwrap_or(0))).into(),
        (6, tlv::TlvItemValueEnc::UInt8(credential_rule.map(|e| e.to_u8()).unwrap_or(0))).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode GetUser command (0x1B)
pub fn encode_get_user(user_index: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(user_index)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode ClearUser command (0x1D)
pub fn encode_clear_user(user_index: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(user_index)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetCredential command (0x22)
pub fn encode_set_credential(operation_type: DataOperationType, credential: Credential, credential_data: Vec<u8>, user_index: Option<u16>, user_status: Option<UserStatus>, user_type: Option<UserType>) -> anyhow::Result<Vec<u8>> {
            // Encode struct CredentialStruct
            let mut credential_fields = Vec::new();
            if let Some(x) = credential.credential_type { credential_fields.push((0, tlv::TlvItemValueEnc::UInt8(x.to_u8())).into()); }
            if let Some(x) = credential.credential_index { credential_fields.push((1, tlv::TlvItemValueEnc::UInt16(x as u16)).into()); }
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(operation_type.to_u8())).into(),
        (1, tlv::TlvItemValueEnc::StructInvisible(credential_fields)).into(),
        (2, tlv::TlvItemValueEnc::OctetString(credential_data)).into(),
        (3, tlv::TlvItemValueEnc::UInt16(user_index.unwrap_or(0))).into(),
        (4, tlv::TlvItemValueEnc::UInt8(user_status.map(|e| e.to_u8()).unwrap_or(0))).into(),
        (5, tlv::TlvItemValueEnc::UInt8(user_type.map(|e| e.to_u8()).unwrap_or(0))).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode GetCredentialStatus command (0x24)
pub fn encode_get_credential_status(credential: Credential) -> anyhow::Result<Vec<u8>> {
            // Encode struct CredentialStruct
            let mut credential_fields = Vec::new();
            if let Some(x) = credential.credential_type { credential_fields.push((0, tlv::TlvItemValueEnc::UInt8(x.to_u8())).into()); }
            if let Some(x) = credential.credential_index { credential_fields.push((1, tlv::TlvItemValueEnc::UInt16(x as u16)).into()); }
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::StructInvisible(credential_fields)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode ClearCredential command (0x26)
pub fn encode_clear_credential(credential: Option<Credential>) -> anyhow::Result<Vec<u8>> {
            // Encode optional struct CredentialStruct
            let credential_enc = if let Some(s) = credential {
                let mut fields = Vec::new();
                if let Some(x) = s.credential_type { fields.push((0, tlv::TlvItemValueEnc::UInt8(x.to_u8())).into()); }
                if let Some(x) = s.credential_index { fields.push((1, tlv::TlvItemValueEnc::UInt16(x as u16)).into()); }
                tlv::TlvItemValueEnc::StructInvisible(fields)
            } else {
                tlv::TlvItemValueEnc::StructInvisible(Vec::new())
            };
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, credential_enc).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode UnboltDoor command (0x27)
pub fn encode_unbolt_door(pin_code: Vec<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::OctetString(pin_code)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetAliroReaderConfig command (0x28)
pub fn encode_set_aliro_reader_config(signing_key: Vec<u8>, verification_key: Vec<u8>, group_identifier: Vec<u8>, group_resolving_key: Vec<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::OctetString(signing_key)).into(),
        (1, tlv::TlvItemValueEnc::OctetString(verification_key)).into(),
        (2, tlv::TlvItemValueEnc::OctetString(group_identifier)).into(),
        (3, tlv::TlvItemValueEnc::OctetString(group_resolving_key)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

// Attribute decoders

/// Decode LockState attribute (0x0000)
pub fn decode_lock_state(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<LockState>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(LockState::from_u8(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode LockType attribute (0x0001)
pub fn decode_lock_type(inp: &tlv::TlvItemValue) -> anyhow::Result<LockType> {
    if let tlv::TlvItemValue::Int(v) = inp {
        LockType::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode ActuatorEnabled attribute (0x0002)
pub fn decode_actuator_enabled(inp: &tlv::TlvItemValue) -> anyhow::Result<bool> {
    if let tlv::TlvItemValue::Bool(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected Bool"))
    }
}

/// Decode DoorState attribute (0x0003)
pub fn decode_door_state(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<DoorState>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(DoorState::from_u8(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode DoorOpenEvents attribute (0x0004)
pub fn decode_door_open_events(inp: &tlv::TlvItemValue) -> anyhow::Result<u32> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u32)
    } else {
        Err(anyhow::anyhow!("Expected UInt32"))
    }
}

/// Decode DoorClosedEvents attribute (0x0005)
pub fn decode_door_closed_events(inp: &tlv::TlvItemValue) -> anyhow::Result<u32> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u32)
    } else {
        Err(anyhow::anyhow!("Expected UInt32"))
    }
}

/// Decode OpenPeriod attribute (0x0006)
pub fn decode_open_period(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected UInt16"))
    }
}

/// Decode NumberOfTotalUsersSupported attribute (0x0011)
pub fn decode_number_of_total_users_supported(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected UInt16"))
    }
}

/// Decode NumberOfPINUsersSupported attribute (0x0012)
pub fn decode_number_of_pin_users_supported(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected UInt16"))
    }
}

/// Decode NumberOfRFIDUsersSupported attribute (0x0013)
pub fn decode_number_of_rfid_users_supported(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected UInt16"))
    }
}

/// Decode NumberOfWeekDaySchedulesSupportedPerUser attribute (0x0014)
pub fn decode_number_of_week_day_schedules_supported_per_user(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode NumberOfYearDaySchedulesSupportedPerUser attribute (0x0015)
pub fn decode_number_of_year_day_schedules_supported_per_user(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode NumberOfHolidaySchedulesSupported attribute (0x0016)
pub fn decode_number_of_holiday_schedules_supported(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode MaxPINCodeLength attribute (0x0017)
pub fn decode_max_pin_code_length(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode MinPINCodeLength attribute (0x0018)
pub fn decode_min_pin_code_length(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode MaxRFIDCodeLength attribute (0x0019)
pub fn decode_max_rfid_code_length(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode MinRFIDCodeLength attribute (0x001A)
pub fn decode_min_rfid_code_length(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode CredentialRulesSupport attribute (0x001B)
pub fn decode_credential_rules_support(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode NumberOfCredentialsSupportedPerUser attribute (0x001C)
pub fn decode_number_of_credentials_supported_per_user(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode Language attribute (0x0021)
pub fn decode_language(inp: &tlv::TlvItemValue) -> anyhow::Result<String> {
    if let tlv::TlvItemValue::String(v) = inp {
        Ok(v.clone())
    } else {
        Err(anyhow::anyhow!("Expected String"))
    }
}

/// Decode LEDSettings attribute (0x0022)
pub fn decode_led_settings(inp: &tlv::TlvItemValue) -> anyhow::Result<LEDSetting> {
    if let tlv::TlvItemValue::Int(v) = inp {
        LEDSetting::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode AutoRelockTime attribute (0x0023)
pub fn decode_auto_relock_time(inp: &tlv::TlvItemValue) -> anyhow::Result<u32> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u32)
    } else {
        Err(anyhow::anyhow!("Expected UInt32"))
    }
}

/// Decode SoundVolume attribute (0x0024)
pub fn decode_sound_volume(inp: &tlv::TlvItemValue) -> anyhow::Result<SoundVolume> {
    if let tlv::TlvItemValue::Int(v) = inp {
        SoundVolume::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode OperatingMode attribute (0x0025)
pub fn decode_operating_mode(inp: &tlv::TlvItemValue) -> anyhow::Result<OperatingMode> {
    if let tlv::TlvItemValue::Int(v) = inp {
        OperatingMode::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode SupportedOperatingModes attribute (0x0026)
pub fn decode_supported_operating_modes(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode DefaultConfigurationRegister attribute (0x0027)
pub fn decode_default_configuration_register(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode EnableLocalProgramming attribute (0x0028)
pub fn decode_enable_local_programming(inp: &tlv::TlvItemValue) -> anyhow::Result<bool> {
    if let tlv::TlvItemValue::Bool(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected Bool"))
    }
}

/// Decode EnableOneTouchLocking attribute (0x0029)
pub fn decode_enable_one_touch_locking(inp: &tlv::TlvItemValue) -> anyhow::Result<bool> {
    if let tlv::TlvItemValue::Bool(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected Bool"))
    }
}

/// Decode EnableInsideStatusLED attribute (0x002A)
pub fn decode_enable_inside_status_led(inp: &tlv::TlvItemValue) -> anyhow::Result<bool> {
    if let tlv::TlvItemValue::Bool(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected Bool"))
    }
}

/// Decode EnablePrivacyModeButton attribute (0x002B)
pub fn decode_enable_privacy_mode_button(inp: &tlv::TlvItemValue) -> anyhow::Result<bool> {
    if let tlv::TlvItemValue::Bool(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected Bool"))
    }
}

/// Decode LocalProgrammingFeatures attribute (0x002C)
pub fn decode_local_programming_features(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode WrongCodeEntryLimit attribute (0x0030)
pub fn decode_wrong_code_entry_limit(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode UserCodeTemporaryDisableTime attribute (0x0031)
pub fn decode_user_code_temporary_disable_time(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode SendPINOverTheAir attribute (0x0032)
pub fn decode_send_pin_over_the_air(inp: &tlv::TlvItemValue) -> anyhow::Result<bool> {
    if let tlv::TlvItemValue::Bool(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected Bool"))
    }
}

/// Decode RequirePINforRemoteOperation attribute (0x0033)
pub fn decode_require_pinfor_remote_operation(inp: &tlv::TlvItemValue) -> anyhow::Result<bool> {
    if let tlv::TlvItemValue::Bool(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected Bool"))
    }
}

/// Decode SecurityLevel attribute (0x0034)
pub fn decode_security_level(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode ExpiringUserTimeout attribute (0x0035)
pub fn decode_expiring_user_timeout(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected UInt16"))
    }
}

/// Decode AliroReaderVerificationKey attribute (0x0080)
pub fn decode_aliro_reader_verification_key(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<Vec<u8>>> {
    if let tlv::TlvItemValue::OctetString(v) = inp {
        Ok(Some(v.clone()))
    } else {
        Ok(None)
    }
}

/// Decode AliroReaderGroupIdentifier attribute (0x0081)
pub fn decode_aliro_reader_group_identifier(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<Vec<u8>>> {
    if let tlv::TlvItemValue::OctetString(v) = inp {
        Ok(Some(v.clone()))
    } else {
        Ok(None)
    }
}

/// Decode AliroReaderGroupSubIdentifier attribute (0x0082)
pub fn decode_aliro_reader_group_sub_identifier(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<u8>> {
    if let tlv::TlvItemValue::OctetString(v) = inp {
        Ok(v.clone())
    } else {
        Err(anyhow::anyhow!("Expected OctetString"))
    }
}

/// Decode AliroExpeditedTransactionSupportedProtocolVersions attribute (0x0083)
pub fn decode_aliro_expedited_transaction_supported_protocol_versions(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<Vec<u8>>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            if let tlv::TlvItemValue::OctetString(o) = &item.value {
                res.push(o.clone());
            }
        }
    }
    Ok(res)
}

/// Decode AliroGroupResolvingKey attribute (0x0084)
pub fn decode_aliro_group_resolving_key(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<Vec<u8>>> {
    if let tlv::TlvItemValue::OctetString(v) = inp {
        Ok(Some(v.clone()))
    } else {
        Ok(None)
    }
}

/// Decode AliroSupportedBLEUWBProtocolVersions attribute (0x0085)
pub fn decode_aliro_supported_bleuwb_protocol_versions(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<Vec<u8>>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            if let tlv::TlvItemValue::OctetString(o) = &item.value {
                res.push(o.clone());
            }
        }
    }
    Ok(res)
}

/// Decode AliroBLEAdvertisingVersion attribute (0x0086)
pub fn decode_aliro_ble_advertising_version(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode NumberOfAliroCredentialIssuerKeysSupported attribute (0x0087)
pub fn decode_number_of_aliro_credential_issuer_keys_supported(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected UInt16"))
    }
}

/// Decode NumberOfAliroEndpointKeysSupported attribute (0x0088)
pub fn decode_number_of_aliro_endpoint_keys_supported(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected UInt16"))
    }
}


// JSON dispatcher function

/// Decode attribute value and return as JSON string
/// 
/// # Parameters
/// * `cluster_id` - The cluster identifier
/// * `attribute_id` - The attribute identifier
/// * `tlv_value` - The TLV value to decode
/// 
/// # Returns
/// JSON string representation of the decoded value or error
pub fn decode_attribute_json(cluster_id: u32, attribute_id: u32, tlv_value: &crate::tlv::TlvItemValue) -> String {
    // Verify this is the correct cluster
    if cluster_id != 0x0101 {
        return format!("{{\"error\": \"Invalid cluster ID. Expected 0x0101, got {}\"}}", cluster_id);
    }
    
    match attribute_id {
        0x0000 => {
            match decode_lock_state(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0001 => {
            match decode_lock_type(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0002 => {
            match decode_actuator_enabled(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0003 => {
            match decode_door_state(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0004 => {
            match decode_door_open_events(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0005 => {
            match decode_door_closed_events(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0006 => {
            match decode_open_period(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0011 => {
            match decode_number_of_total_users_supported(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0012 => {
            match decode_number_of_pin_users_supported(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0013 => {
            match decode_number_of_rfid_users_supported(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0014 => {
            match decode_number_of_week_day_schedules_supported_per_user(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0015 => {
            match decode_number_of_year_day_schedules_supported_per_user(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0016 => {
            match decode_number_of_holiday_schedules_supported(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0017 => {
            match decode_max_pin_code_length(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0018 => {
            match decode_min_pin_code_length(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0019 => {
            match decode_max_rfid_code_length(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x001A => {
            match decode_min_rfid_code_length(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x001B => {
            match decode_credential_rules_support(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x001C => {
            match decode_number_of_credentials_supported_per_user(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0021 => {
            match decode_language(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0022 => {
            match decode_led_settings(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0023 => {
            match decode_auto_relock_time(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0024 => {
            match decode_sound_volume(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0025 => {
            match decode_operating_mode(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0026 => {
            match decode_supported_operating_modes(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0027 => {
            match decode_default_configuration_register(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0028 => {
            match decode_enable_local_programming(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0029 => {
            match decode_enable_one_touch_locking(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x002A => {
            match decode_enable_inside_status_led(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x002B => {
            match decode_enable_privacy_mode_button(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x002C => {
            match decode_local_programming_features(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0030 => {
            match decode_wrong_code_entry_limit(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0031 => {
            match decode_user_code_temporary_disable_time(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0032 => {
            match decode_send_pin_over_the_air(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0033 => {
            match decode_require_pinfor_remote_operation(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0034 => {
            match decode_security_level(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0035 => {
            match decode_expiring_user_timeout(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0080 => {
            match decode_aliro_reader_verification_key(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0081 => {
            match decode_aliro_reader_group_identifier(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0082 => {
            match decode_aliro_reader_group_sub_identifier(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0083 => {
            match decode_aliro_expedited_transaction_supported_protocol_versions(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0084 => {
            match decode_aliro_group_resolving_key(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0085 => {
            match decode_aliro_supported_bleuwb_protocol_versions(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0086 => {
            match decode_aliro_ble_advertising_version(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0087 => {
            match decode_number_of_aliro_credential_issuer_keys_supported(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0088 => {
            match decode_number_of_aliro_endpoint_keys_supported(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        _ => format!("{{\"error\": \"Unknown attribute ID: {}\"}}", attribute_id),
    }
}

/// Get list of all attributes supported by this cluster
/// 
/// # Returns
/// Vector of tuples containing (attribute_id, attribute_name)
pub fn get_attribute_list() -> Vec<(u32, &'static str)> {
    vec![
        (0x0000, "LockState"),
        (0x0001, "LockType"),
        (0x0002, "ActuatorEnabled"),
        (0x0003, "DoorState"),
        (0x0004, "DoorOpenEvents"),
        (0x0005, "DoorClosedEvents"),
        (0x0006, "OpenPeriod"),
        (0x0011, "NumberOfTotalUsersSupported"),
        (0x0012, "NumberOfPINUsersSupported"),
        (0x0013, "NumberOfRFIDUsersSupported"),
        (0x0014, "NumberOfWeekDaySchedulesSupportedPerUser"),
        (0x0015, "NumberOfYearDaySchedulesSupportedPerUser"),
        (0x0016, "NumberOfHolidaySchedulesSupported"),
        (0x0017, "MaxPINCodeLength"),
        (0x0018, "MinPINCodeLength"),
        (0x0019, "MaxRFIDCodeLength"),
        (0x001A, "MinRFIDCodeLength"),
        (0x001B, "CredentialRulesSupport"),
        (0x001C, "NumberOfCredentialsSupportedPerUser"),
        (0x0021, "Language"),
        (0x0022, "LEDSettings"),
        (0x0023, "AutoRelockTime"),
        (0x0024, "SoundVolume"),
        (0x0025, "OperatingMode"),
        (0x0026, "SupportedOperatingModes"),
        (0x0027, "DefaultConfigurationRegister"),
        (0x0028, "EnableLocalProgramming"),
        (0x0029, "EnableOneTouchLocking"),
        (0x002A, "EnableInsideStatusLED"),
        (0x002B, "EnablePrivacyModeButton"),
        (0x002C, "LocalProgrammingFeatures"),
        (0x0030, "WrongCodeEntryLimit"),
        (0x0031, "UserCodeTemporaryDisableTime"),
        (0x0032, "SendPINOverTheAir"),
        (0x0033, "RequirePINforRemoteOperation"),
        (0x0034, "SecurityLevel"),
        (0x0035, "ExpiringUserTimeout"),
        (0x0080, "AliroReaderVerificationKey"),
        (0x0081, "AliroReaderGroupIdentifier"),
        (0x0082, "AliroReaderGroupSubIdentifier"),
        (0x0083, "AliroExpeditedTransactionSupportedProtocolVersions"),
        (0x0084, "AliroGroupResolvingKey"),
        (0x0085, "AliroSupportedBLEUWBProtocolVersions"),
        (0x0086, "AliroBLEAdvertisingVersion"),
        (0x0087, "NumberOfAliroCredentialIssuerKeysSupported"),
        (0x0088, "NumberOfAliroEndpointKeysSupported"),
    ]
}

