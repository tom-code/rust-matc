//! Matter TLV encoders and decoders for Push AV Stream Transport Cluster
//! Cluster ID: 0x0555
//!
//! This file is automatically generated from PushAVStreamTransport.xml

use crate::tlv;
use anyhow;
use serde_json;


// Import serialization helpers for octet strings
use crate::clusters::helpers::{serialize_opt_bytes_as_hex};

// Enum definitions

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum CMAFInterface {
    /// CMAF Interface-1 Mode
    Interface1 = 0,
    /// CMAF Interface-2 Mode with DASH Support
    Interface2dash = 1,
    /// CMAF Interface-2 Mode with HLS Support
    Interface2hls = 2,
}

impl CMAFInterface {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(CMAFInterface::Interface1),
            1 => Some(CMAFInterface::Interface2dash),
            2 => Some(CMAFInterface::Interface2hls),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<CMAFInterface> for u8 {
    fn from(val: CMAFInterface) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ContainerFormat {
    /// CMAF container format
    Cmaf = 0,
}

impl ContainerFormat {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(ContainerFormat::Cmaf),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<ContainerFormat> for u8 {
    fn from(val: ContainerFormat) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum IngestMethods {
    /// CMAF ingestion format
    Cmafingest = 0,
}

impl IngestMethods {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(IngestMethods::Cmafingest),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<IngestMethods> for u8 {
    fn from(val: IngestMethods) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum StatusCode {
    /// The specified TLSEndpointID cannot be found.
    Invalidtlsendpoint = 2,
    /// The specified VideoStreamID or AudioStreamID cannot be found.
    Invalidstream = 3,
    /// The specified URL is invalid.
    Invalidurl = 4,
    /// A specified ZoneID was invalid.
    Invalidzone = 5,
    /// The specified combination of Ingestion method and Container format is not supported.
    Invalidcombination = 6,
    /// The trigger type is invalid for this command.
    Invalidtriggertype = 7,
    /// The Stream Transport Status is invalid for this command.
    Invalidtransportstatus = 8,
    /// The requested Container options are not supported with the streams indicated.
    Invalidoptions = 9,
    /// The requested StreamUsage is not allowed.
    Invalidstreamusage = 10,
    /// Time sync has not occurred yet.
    Invalidtime = 11,
    /// The requested pre roll length is not compatible with the streams key frame interval.
    Invalidprerolllength = 12,
    /// The requested Streams info contained duplicate entries.
    Duplicatestreamvalues = 13,
}

impl StatusCode {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            2 => Some(StatusCode::Invalidtlsendpoint),
            3 => Some(StatusCode::Invalidstream),
            4 => Some(StatusCode::Invalidurl),
            5 => Some(StatusCode::Invalidzone),
            6 => Some(StatusCode::Invalidcombination),
            7 => Some(StatusCode::Invalidtriggertype),
            8 => Some(StatusCode::Invalidtransportstatus),
            9 => Some(StatusCode::Invalidoptions),
            10 => Some(StatusCode::Invalidstreamusage),
            11 => Some(StatusCode::Invalidtime),
            12 => Some(StatusCode::Invalidprerolllength),
            13 => Some(StatusCode::Duplicatestreamvalues),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<StatusCode> for u8 {
    fn from(val: StatusCode) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum TransportStatus {
    /// Push Transport can transport AV Streams
    Active = 0,
    /// Push Transport cannot transport AV Streams
    Inactive = 1,
}

impl TransportStatus {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(TransportStatus::Active),
            1 => Some(TransportStatus::Inactive),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<TransportStatus> for u8 {
    fn from(val: TransportStatus) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum TransportTriggerType {
    /// Triggered only via a command invocation
    Command = 0,
    /// Triggered via motion detection or command
    Motion = 1,
    /// Triggered always when transport status is Active
    Continuous = 2,
}

impl TransportTriggerType {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(TransportTriggerType::Command),
            1 => Some(TransportTriggerType::Motion),
            2 => Some(TransportTriggerType::Continuous),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<TransportTriggerType> for u8 {
    fn from(val: TransportTriggerType) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum TriggerActivationReason {
    /// Trigger has been activated by user action
    Userinitiated = 0,
    /// Trigger has been activated by automation
    Automation = 1,
    /// Trigger has been activated for emergency reasons
    Emergency = 2,
    /// Trigger has been activated by a doorbell press
    Doorbellpressed = 3,
}

impl TriggerActivationReason {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(TriggerActivationReason::Userinitiated),
            1 => Some(TriggerActivationReason::Automation),
            2 => Some(TriggerActivationReason::Emergency),
            3 => Some(TriggerActivationReason::Doorbellpressed),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<TriggerActivationReason> for u8 {
    fn from(val: TriggerActivationReason) -> Self {
        val as u8
    }
}

// Struct definitions

#[derive(Debug, serde::Serialize)]
pub struct AudioStream {
    pub audio_stream_name: Option<String>,
    pub audio_stream_id: Option<u8>,
}

#[derive(Debug, serde::Serialize)]
pub struct CMAFContainerOptions {
    pub cmaf_interface: Option<CMAFInterface>,
    pub segment_duration: Option<u16>,
    pub chunk_duration: Option<u16>,
    pub session_group: Option<u8>,
    pub track_name: Option<String>,
    #[serde(serialize_with = "serialize_opt_bytes_as_hex")]
    pub cenc_key: Option<Vec<u8>>,
    #[serde(serialize_with = "serialize_opt_bytes_as_hex")]
    pub cenc_key_id: Option<Vec<u8>>,
    pub metadata_enabled: Option<bool>,
}

#[derive(Debug, serde::Serialize)]
pub struct ContainerOptions {
    pub container_type: Option<ContainerFormat>,
    pub cmaf_container_options: Option<CMAFContainerOptions>,
}

#[derive(Debug, serde::Serialize)]
pub struct SupportedFormat {
    pub container_format: Option<ContainerFormat>,
    pub ingest_method: Option<IngestMethods>,
}

#[derive(Debug, serde::Serialize)]
pub struct TransportConfiguration {
    pub connection_id: Option<u8>,
    pub transport_status: Option<TransportStatus>,
    pub transport_options: Option<TransportOptions>,
}

#[derive(Debug, serde::Serialize)]
pub struct TransportMotionTriggerTimeControl {
    pub initial_duration: Option<u16>,
    pub augmentation_duration: Option<u16>,
    pub max_duration: Option<u32>,
    pub blind_duration: Option<u16>,
}

#[derive(Debug, serde::Serialize)]
pub struct TransportOptions {
    pub stream_usage: Option<u8>,
    pub video_stream_id: Option<u8>,
    pub audio_stream_id: Option<u8>,
    pub tls_endpoint_id: Option<u8>,
    pub url: Option<String>,
    pub trigger_options: Option<TransportTriggerOptions>,
    pub ingest_method: Option<IngestMethods>,
    pub container_options: Option<ContainerOptions>,
    pub expiry_time: Option<u64>,
    pub video_streams: Option<Vec<VideoStream>>,
    pub audio_streams: Option<Vec<AudioStream>>,
}

#[derive(Debug, serde::Serialize)]
pub struct TransportTriggerOptions {
    pub trigger_type: Option<TransportTriggerType>,
    pub motion_zones: Option<Vec<TransportZoneOptions>>,
    pub motion_sensitivity: Option<u8>,
    pub motion_time_control: Option<TransportMotionTriggerTimeControl>,
    pub max_pre_roll_len: Option<u16>,
}

#[derive(Debug, serde::Serialize)]
pub struct TransportZoneOptions {
    pub zone: Option<u8>,
    pub sensitivity: Option<u8>,
}

#[derive(Debug, serde::Serialize)]
pub struct VideoStream {
    pub video_stream_name: Option<String>,
    pub video_stream_id: Option<u8>,
}

// Command encoders

/// Encode AllocatePushTransport command (0x00)
pub fn encode_allocate_push_transport(transport_options: TransportOptions) -> anyhow::Result<Vec<u8>> {
            // Encode struct TransportOptionsStruct
            let mut transport_options_fields = Vec::new();
            if let Some(x) = transport_options.stream_usage { transport_options_fields.push((0, tlv::TlvItemValueEnc::UInt8(x)).into()); }
            // TODO: encoding for field video_stream_id (VideoStreamID) not implemented
            // TODO: encoding for field audio_stream_id (AudioStreamID) not implemented
            // TODO: encoding for field tls_endpoint_id (TLSEndpointID) not implemented
            if let Some(x) = transport_options.url { transport_options_fields.push((4, tlv::TlvItemValueEnc::String(x.clone())).into()); }
            if let Some(inner) = transport_options.trigger_options {
                let mut trigger_options_nested_fields = Vec::new();
                if let Some(x) = inner.trigger_type { trigger_options_nested_fields.push((0, tlv::TlvItemValueEnc::UInt8(x.to_u8())).into()); }
                if let Some(listv) = inner.motion_zones {
                    let inner_vec: Vec<_> = listv.into_iter().map(|inner| {
                        let mut nested_fields = Vec::new();
                            // TODO: encoding for field zone (ZoneID) not implemented
                            if let Some(x) = inner.sensitivity { nested_fields.push((1, tlv::TlvItemValueEnc::UInt8(x)).into()); }
                        (0, tlv::TlvItemValueEnc::StructAnon(nested_fields)).into()
                    }).collect();
                    trigger_options_nested_fields.push((1, tlv::TlvItemValueEnc::Array(inner_vec)).into());
                }
                if let Some(x) = inner.motion_sensitivity { trigger_options_nested_fields.push((2, tlv::TlvItemValueEnc::UInt8(x)).into()); }
                if let Some(inner) = inner.motion_time_control {
                    let mut motion_time_control_nested_fields = Vec::new();
                    if let Some(x) = inner.initial_duration { motion_time_control_nested_fields.push((0, tlv::TlvItemValueEnc::UInt16(x)).into()); }
                    if let Some(x) = inner.augmentation_duration { motion_time_control_nested_fields.push((1, tlv::TlvItemValueEnc::UInt16(x)).into()); }
                    if let Some(x) = inner.max_duration { motion_time_control_nested_fields.push((2, tlv::TlvItemValueEnc::UInt32(x)).into()); }
                    if let Some(x) = inner.blind_duration { motion_time_control_nested_fields.push((3, tlv::TlvItemValueEnc::UInt16(x)).into()); }
                    trigger_options_nested_fields.push((3, tlv::TlvItemValueEnc::StructInvisible(motion_time_control_nested_fields)).into());
                }
                if let Some(x) = inner.max_pre_roll_len { trigger_options_nested_fields.push((4, tlv::TlvItemValueEnc::UInt16(x)).into()); }
                transport_options_fields.push((5, tlv::TlvItemValueEnc::StructInvisible(trigger_options_nested_fields)).into());
            }
            if let Some(x) = transport_options.ingest_method { transport_options_fields.push((6, tlv::TlvItemValueEnc::UInt8(x.to_u8())).into()); }
            if let Some(inner) = transport_options.container_options {
                let mut container_options_nested_fields = Vec::new();
                if let Some(x) = inner.container_type { container_options_nested_fields.push((0, tlv::TlvItemValueEnc::UInt8(x.to_u8())).into()); }
                if let Some(inner) = inner.cmaf_container_options {
                    let mut cmaf_container_options_nested_fields = Vec::new();
                    if let Some(x) = inner.cmaf_interface { cmaf_container_options_nested_fields.push((0, tlv::TlvItemValueEnc::UInt8(x.to_u8())).into()); }
                    if let Some(x) = inner.segment_duration { cmaf_container_options_nested_fields.push((1, tlv::TlvItemValueEnc::UInt16(x)).into()); }
                    if let Some(x) = inner.chunk_duration { cmaf_container_options_nested_fields.push((2, tlv::TlvItemValueEnc::UInt16(x)).into()); }
                    if let Some(x) = inner.session_group { cmaf_container_options_nested_fields.push((3, tlv::TlvItemValueEnc::UInt8(x)).into()); }
                    if let Some(x) = inner.track_name { cmaf_container_options_nested_fields.push((4, tlv::TlvItemValueEnc::String(x.clone())).into()); }
                    if let Some(x) = inner.cenc_key { cmaf_container_options_nested_fields.push((5, tlv::TlvItemValueEnc::OctetString(x.clone())).into()); }
                    if let Some(x) = inner.cenc_key_id { cmaf_container_options_nested_fields.push((6, tlv::TlvItemValueEnc::OctetString(x.clone())).into()); }
                    if let Some(x) = inner.metadata_enabled { cmaf_container_options_nested_fields.push((7, tlv::TlvItemValueEnc::Bool(x)).into()); }
                    container_options_nested_fields.push((1, tlv::TlvItemValueEnc::StructInvisible(cmaf_container_options_nested_fields)).into());
                }
                transport_options_fields.push((7, tlv::TlvItemValueEnc::StructInvisible(container_options_nested_fields)).into());
            }
            if let Some(x) = transport_options.expiry_time { transport_options_fields.push((8, tlv::TlvItemValueEnc::UInt64(x)).into()); }
            if let Some(listv) = transport_options.video_streams {
                let inner_vec: Vec<_> = listv.into_iter().map(|inner| {
                    let mut nested_fields = Vec::new();
                        if let Some(x) = inner.video_stream_name { nested_fields.push((0, tlv::TlvItemValueEnc::String(x.clone())).into()); }
                        // TODO: encoding for field video_stream_id (VideoStreamID) not implemented
                    (0, tlv::TlvItemValueEnc::StructAnon(nested_fields)).into()
                }).collect();
                transport_options_fields.push((9, tlv::TlvItemValueEnc::Array(inner_vec)).into());
            }
            if let Some(listv) = transport_options.audio_streams {
                let inner_vec: Vec<_> = listv.into_iter().map(|inner| {
                    let mut nested_fields = Vec::new();
                        if let Some(x) = inner.audio_stream_name { nested_fields.push((0, tlv::TlvItemValueEnc::String(x.clone())).into()); }
                        // TODO: encoding for field audio_stream_id (AudioStreamID) not implemented
                    (0, tlv::TlvItemValueEnc::StructAnon(nested_fields)).into()
                }).collect();
                transport_options_fields.push((10, tlv::TlvItemValueEnc::Array(inner_vec)).into());
            }
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::StructInvisible(transport_options_fields)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode DeallocatePushTransport command (0x02)
pub fn encode_deallocate_push_transport(connection_id: u8) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(connection_id)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode ModifyPushTransport command (0x03)
pub fn encode_modify_push_transport(connection_id: u8, transport_options: TransportOptions) -> anyhow::Result<Vec<u8>> {
            // Encode struct TransportOptionsStruct
            let mut transport_options_fields = Vec::new();
            if let Some(x) = transport_options.stream_usage { transport_options_fields.push((0, tlv::TlvItemValueEnc::UInt8(x)).into()); }
            // TODO: encoding for field video_stream_id (VideoStreamID) not implemented
            // TODO: encoding for field audio_stream_id (AudioStreamID) not implemented
            // TODO: encoding for field tls_endpoint_id (TLSEndpointID) not implemented
            if let Some(x) = transport_options.url { transport_options_fields.push((4, tlv::TlvItemValueEnc::String(x.clone())).into()); }
            if let Some(inner) = transport_options.trigger_options {
                let mut trigger_options_nested_fields = Vec::new();
                if let Some(x) = inner.trigger_type { trigger_options_nested_fields.push((0, tlv::TlvItemValueEnc::UInt8(x.to_u8())).into()); }
                if let Some(listv) = inner.motion_zones {
                    let inner_vec: Vec<_> = listv.into_iter().map(|inner| {
                        let mut nested_fields = Vec::new();
                            // TODO: encoding for field zone (ZoneID) not implemented
                            if let Some(x) = inner.sensitivity { nested_fields.push((1, tlv::TlvItemValueEnc::UInt8(x)).into()); }
                        (0, tlv::TlvItemValueEnc::StructAnon(nested_fields)).into()
                    }).collect();
                    trigger_options_nested_fields.push((1, tlv::TlvItemValueEnc::Array(inner_vec)).into());
                }
                if let Some(x) = inner.motion_sensitivity { trigger_options_nested_fields.push((2, tlv::TlvItemValueEnc::UInt8(x)).into()); }
                if let Some(inner) = inner.motion_time_control {
                    let mut motion_time_control_nested_fields = Vec::new();
                    if let Some(x) = inner.initial_duration { motion_time_control_nested_fields.push((0, tlv::TlvItemValueEnc::UInt16(x)).into()); }
                    if let Some(x) = inner.augmentation_duration { motion_time_control_nested_fields.push((1, tlv::TlvItemValueEnc::UInt16(x)).into()); }
                    if let Some(x) = inner.max_duration { motion_time_control_nested_fields.push((2, tlv::TlvItemValueEnc::UInt32(x)).into()); }
                    if let Some(x) = inner.blind_duration { motion_time_control_nested_fields.push((3, tlv::TlvItemValueEnc::UInt16(x)).into()); }
                    trigger_options_nested_fields.push((3, tlv::TlvItemValueEnc::StructInvisible(motion_time_control_nested_fields)).into());
                }
                if let Some(x) = inner.max_pre_roll_len { trigger_options_nested_fields.push((4, tlv::TlvItemValueEnc::UInt16(x)).into()); }
                transport_options_fields.push((5, tlv::TlvItemValueEnc::StructInvisible(trigger_options_nested_fields)).into());
            }
            if let Some(x) = transport_options.ingest_method { transport_options_fields.push((6, tlv::TlvItemValueEnc::UInt8(x.to_u8())).into()); }
            if let Some(inner) = transport_options.container_options {
                let mut container_options_nested_fields = Vec::new();
                if let Some(x) = inner.container_type { container_options_nested_fields.push((0, tlv::TlvItemValueEnc::UInt8(x.to_u8())).into()); }
                if let Some(inner) = inner.cmaf_container_options {
                    let mut cmaf_container_options_nested_fields = Vec::new();
                    if let Some(x) = inner.cmaf_interface { cmaf_container_options_nested_fields.push((0, tlv::TlvItemValueEnc::UInt8(x.to_u8())).into()); }
                    if let Some(x) = inner.segment_duration { cmaf_container_options_nested_fields.push((1, tlv::TlvItemValueEnc::UInt16(x)).into()); }
                    if let Some(x) = inner.chunk_duration { cmaf_container_options_nested_fields.push((2, tlv::TlvItemValueEnc::UInt16(x)).into()); }
                    if let Some(x) = inner.session_group { cmaf_container_options_nested_fields.push((3, tlv::TlvItemValueEnc::UInt8(x)).into()); }
                    if let Some(x) = inner.track_name { cmaf_container_options_nested_fields.push((4, tlv::TlvItemValueEnc::String(x.clone())).into()); }
                    if let Some(x) = inner.cenc_key { cmaf_container_options_nested_fields.push((5, tlv::TlvItemValueEnc::OctetString(x.clone())).into()); }
                    if let Some(x) = inner.cenc_key_id { cmaf_container_options_nested_fields.push((6, tlv::TlvItemValueEnc::OctetString(x.clone())).into()); }
                    if let Some(x) = inner.metadata_enabled { cmaf_container_options_nested_fields.push((7, tlv::TlvItemValueEnc::Bool(x)).into()); }
                    container_options_nested_fields.push((1, tlv::TlvItemValueEnc::StructInvisible(cmaf_container_options_nested_fields)).into());
                }
                transport_options_fields.push((7, tlv::TlvItemValueEnc::StructInvisible(container_options_nested_fields)).into());
            }
            if let Some(x) = transport_options.expiry_time { transport_options_fields.push((8, tlv::TlvItemValueEnc::UInt64(x)).into()); }
            if let Some(listv) = transport_options.video_streams {
                let inner_vec: Vec<_> = listv.into_iter().map(|inner| {
                    let mut nested_fields = Vec::new();
                        if let Some(x) = inner.video_stream_name { nested_fields.push((0, tlv::TlvItemValueEnc::String(x.clone())).into()); }
                        // TODO: encoding for field video_stream_id (VideoStreamID) not implemented
                    (0, tlv::TlvItemValueEnc::StructAnon(nested_fields)).into()
                }).collect();
                transport_options_fields.push((9, tlv::TlvItemValueEnc::Array(inner_vec)).into());
            }
            if let Some(listv) = transport_options.audio_streams {
                let inner_vec: Vec<_> = listv.into_iter().map(|inner| {
                    let mut nested_fields = Vec::new();
                        if let Some(x) = inner.audio_stream_name { nested_fields.push((0, tlv::TlvItemValueEnc::String(x.clone())).into()); }
                        // TODO: encoding for field audio_stream_id (AudioStreamID) not implemented
                    (0, tlv::TlvItemValueEnc::StructAnon(nested_fields)).into()
                }).collect();
                transport_options_fields.push((10, tlv::TlvItemValueEnc::Array(inner_vec)).into());
            }
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(connection_id)).into(),
        (1, tlv::TlvItemValueEnc::StructInvisible(transport_options_fields)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetTransportStatus command (0x04)
pub fn encode_set_transport_status(connection_id: Option<u8>, transport_status: TransportStatus) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(connection_id.unwrap_or(0))).into(),
        (1, tlv::TlvItemValueEnc::UInt8(transport_status.to_u8())).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode ManuallyTriggerTransport command (0x05)
pub fn encode_manually_trigger_transport(connection_id: u8, activation_reason: TriggerActivationReason, time_control: TransportMotionTriggerTimeControl, user_defined: Vec<u8>) -> anyhow::Result<Vec<u8>> {
            // Encode struct TransportMotionTriggerTimeControlStruct
            let mut time_control_fields = Vec::new();
            if let Some(x) = time_control.initial_duration { time_control_fields.push((0, tlv::TlvItemValueEnc::UInt16(x)).into()); }
            if let Some(x) = time_control.augmentation_duration { time_control_fields.push((1, tlv::TlvItemValueEnc::UInt16(x)).into()); }
            if let Some(x) = time_control.max_duration { time_control_fields.push((2, tlv::TlvItemValueEnc::UInt32(x)).into()); }
            if let Some(x) = time_control.blind_duration { time_control_fields.push((3, tlv::TlvItemValueEnc::UInt16(x)).into()); }
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(connection_id)).into(),
        (1, tlv::TlvItemValueEnc::UInt8(activation_reason.to_u8())).into(),
        (2, tlv::TlvItemValueEnc::StructInvisible(time_control_fields)).into(),
        (3, tlv::TlvItemValueEnc::OctetString(user_defined)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode FindTransport command (0x06)
pub fn encode_find_transport(connection_id: Option<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(connection_id.unwrap_or(0))).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

// Attribute decoders

/// Decode SupportedFormats attribute (0x0000)
pub fn decode_supported_formats(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<SupportedFormat>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(SupportedFormat {
                container_format: item.get_int(&[0]).and_then(|v| ContainerFormat::from_u8(v as u8)),
                ingest_method: item.get_int(&[1]).and_then(|v| IngestMethods::from_u8(v as u8)),
            });
        }
    }
    Ok(res)
}

/// Decode CurrentConnections attribute (0x0001)
pub fn decode_current_connections(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<TransportConfiguration>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(TransportConfiguration {
                connection_id: item.get_int(&[0]).map(|v| v as u8),
                transport_status: item.get_int(&[1]).and_then(|v| TransportStatus::from_u8(v as u8)),
                transport_options: {
                    if let Some(nested_tlv) = item.get(&[2]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 2, value: nested_tlv.clone() };
                            Some(TransportOptions {
                stream_usage: nested_item.get_int(&[0]).map(|v| v as u8),
                video_stream_id: nested_item.get_int(&[1]).map(|v| v as u8),
                audio_stream_id: nested_item.get_int(&[2]).map(|v| v as u8),
                tls_endpoint_id: nested_item.get_int(&[3]).map(|v| v as u8),
                url: nested_item.get_string_owned(&[4]),
                trigger_options: {
                    if let Some(nested_tlv) = nested_item.get(&[5]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 5, value: nested_tlv.clone() };
                            Some(TransportTriggerOptions {
                trigger_type: nested_item.get_int(&[0]).and_then(|v| TransportTriggerType::from_u8(v as u8)),
                motion_zones: {
                    if let Some(tlv::TlvItemValue::List(l)) = nested_item.get(&[1]) {
                        let mut items = Vec::new();
                        for list_item in l {
                            items.push(TransportZoneOptions {
                zone: list_item.get_int(&[0]).map(|v| v as u8),
                sensitivity: list_item.get_int(&[1]).map(|v| v as u8),
                            });
                        }
                        Some(items)
                    } else {
                        None
                    }
                },
                motion_sensitivity: nested_item.get_int(&[2]).map(|v| v as u8),
                motion_time_control: {
                    if let Some(nested_tlv) = nested_item.get(&[3]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 3, value: nested_tlv.clone() };
                            Some(TransportMotionTriggerTimeControl {
                initial_duration: nested_item.get_int(&[0]).map(|v| v as u16),
                augmentation_duration: nested_item.get_int(&[1]).map(|v| v as u16),
                max_duration: nested_item.get_int(&[2]).map(|v| v as u32),
                blind_duration: nested_item.get_int(&[3]).map(|v| v as u16),
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
                max_pre_roll_len: nested_item.get_int(&[4]).map(|v| v as u16),
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
                ingest_method: nested_item.get_int(&[6]).and_then(|v| IngestMethods::from_u8(v as u8)),
                container_options: {
                    if let Some(nested_tlv) = nested_item.get(&[7]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 7, value: nested_tlv.clone() };
                            Some(ContainerOptions {
                container_type: nested_item.get_int(&[0]).and_then(|v| ContainerFormat::from_u8(v as u8)),
                cmaf_container_options: {
                    if let Some(nested_tlv) = nested_item.get(&[1]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 1, value: nested_tlv.clone() };
                            Some(CMAFContainerOptions {
                cmaf_interface: nested_item.get_int(&[0]).and_then(|v| CMAFInterface::from_u8(v as u8)),
                segment_duration: nested_item.get_int(&[1]).map(|v| v as u16),
                chunk_duration: nested_item.get_int(&[2]).map(|v| v as u16),
                session_group: nested_item.get_int(&[3]).map(|v| v as u8),
                track_name: nested_item.get_string_owned(&[4]),
                cenc_key: nested_item.get_octet_string_owned(&[5]),
                cenc_key_id: nested_item.get_octet_string_owned(&[6]),
                metadata_enabled: nested_item.get_bool(&[7]),
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
                expiry_time: nested_item.get_int(&[8]),
                video_streams: {
                    if let Some(tlv::TlvItemValue::List(l)) = nested_item.get(&[9]) {
                        let mut items = Vec::new();
                        for list_item in l {
                            items.push(VideoStream {
                video_stream_name: list_item.get_string_owned(&[0]),
                video_stream_id: list_item.get_int(&[1]).map(|v| v as u8),
                            });
                        }
                        Some(items)
                    } else {
                        None
                    }
                },
                audio_streams: {
                    if let Some(tlv::TlvItemValue::List(l)) = nested_item.get(&[10]) {
                        let mut items = Vec::new();
                        for list_item in l {
                            items.push(AudioStream {
                audio_stream_name: list_item.get_string_owned(&[0]),
                audio_stream_id: list_item.get_int(&[1]).map(|v| v as u8),
                            });
                        }
                        Some(items)
                    } else {
                        None
                    }
                },
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
            });
        }
    }
    Ok(res)
}


// JSON dispatcher function

/// Decode attribute value and return as JSON string
///
/// # Parameters
/// * `cluster_id` - The cluster identifier
/// * `attribute_id` - The attribute identifier
/// * `tlv_value` - The TLV value to decode
///
/// # Returns
/// JSON string representation of the decoded value or error
pub fn decode_attribute_json(cluster_id: u32, attribute_id: u32, tlv_value: &crate::tlv::TlvItemValue) -> String {
    // Verify this is the correct cluster
    if cluster_id != 0x0555 {
        return format!("{{\"error\": \"Invalid cluster ID. Expected 0x0555, got {}\"}}", cluster_id);
    }

    match attribute_id {
        0x0000 => {
            match decode_supported_formats(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0001 => {
            match decode_current_connections(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        _ => format!("{{\"error\": \"Unknown attribute ID: {}\"}}", attribute_id),
    }
}

/// Get list of all attributes supported by this cluster
///
/// # Returns
/// Vector of tuples containing (attribute_id, attribute_name)
pub fn get_attribute_list() -> Vec<(u32, &'static str)> {
    vec![
        (0x0000, "SupportedFormats"),
        (0x0001, "CurrentConnections"),
    ]
}

#[derive(Debug, serde::Serialize)]
pub struct AllocatePushTransportResponse {
    pub transport_configuration: Option<TransportConfiguration>,
}

#[derive(Debug, serde::Serialize)]
pub struct FindTransportResponse {
    pub transport_configurations: Option<Vec<TransportConfiguration>>,
}

// Command response decoders

/// Decode AllocatePushTransportResponse command response (01)
pub fn decode_allocate_push_transport_response(inp: &tlv::TlvItemValue) -> anyhow::Result<AllocatePushTransportResponse> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(AllocatePushTransportResponse {
                transport_configuration: {
                    if let Some(nested_tlv) = item.get(&[0]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 0, value: nested_tlv.clone() };
                            Some(TransportConfiguration {
                connection_id: nested_item.get_int(&[0]).map(|v| v as u8),
                transport_status: nested_item.get_int(&[1]).and_then(|v| TransportStatus::from_u8(v as u8)),
                transport_options: {
                    if let Some(nested_tlv) = nested_item.get(&[2]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 2, value: nested_tlv.clone() };
                            Some(TransportOptions {
                stream_usage: nested_item.get_int(&[0]).map(|v| v as u8),
                video_stream_id: nested_item.get_int(&[1]).map(|v| v as u8),
                audio_stream_id: nested_item.get_int(&[2]).map(|v| v as u8),
                tls_endpoint_id: nested_item.get_int(&[3]).map(|v| v as u8),
                url: nested_item.get_string_owned(&[4]),
                trigger_options: {
                    if let Some(nested_tlv) = nested_item.get(&[5]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 5, value: nested_tlv.clone() };
                            Some(TransportTriggerOptions {
                trigger_type: nested_item.get_int(&[0]).and_then(|v| TransportTriggerType::from_u8(v as u8)),
                motion_zones: {
                    if let Some(tlv::TlvItemValue::List(l)) = nested_item.get(&[1]) {
                        let mut items = Vec::new();
                        for list_item in l {
                            items.push(TransportZoneOptions {
                zone: list_item.get_int(&[0]).map(|v| v as u8),
                sensitivity: list_item.get_int(&[1]).map(|v| v as u8),
                            });
                        }
                        Some(items)
                    } else {
                        None
                    }
                },
                motion_sensitivity: nested_item.get_int(&[2]).map(|v| v as u8),
                motion_time_control: {
                    if let Some(nested_tlv) = nested_item.get(&[3]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 3, value: nested_tlv.clone() };
                            Some(TransportMotionTriggerTimeControl {
                initial_duration: nested_item.get_int(&[0]).map(|v| v as u16),
                augmentation_duration: nested_item.get_int(&[1]).map(|v| v as u16),
                max_duration: nested_item.get_int(&[2]).map(|v| v as u32),
                blind_duration: nested_item.get_int(&[3]).map(|v| v as u16),
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
                max_pre_roll_len: nested_item.get_int(&[4]).map(|v| v as u16),
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
                ingest_method: nested_item.get_int(&[6]).and_then(|v| IngestMethods::from_u8(v as u8)),
                container_options: {
                    if let Some(nested_tlv) = nested_item.get(&[7]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 7, value: nested_tlv.clone() };
                            Some(ContainerOptions {
                container_type: nested_item.get_int(&[0]).and_then(|v| ContainerFormat::from_u8(v as u8)),
                cmaf_container_options: {
                    if let Some(nested_tlv) = nested_item.get(&[1]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 1, value: nested_tlv.clone() };
                            Some(CMAFContainerOptions {
                cmaf_interface: nested_item.get_int(&[0]).and_then(|v| CMAFInterface::from_u8(v as u8)),
                segment_duration: nested_item.get_int(&[1]).map(|v| v as u16),
                chunk_duration: nested_item.get_int(&[2]).map(|v| v as u16),
                session_group: nested_item.get_int(&[3]).map(|v| v as u8),
                track_name: nested_item.get_string_owned(&[4]),
                cenc_key: nested_item.get_octet_string_owned(&[5]),
                cenc_key_id: nested_item.get_octet_string_owned(&[6]),
                metadata_enabled: nested_item.get_bool(&[7]),
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
                expiry_time: nested_item.get_int(&[8]),
                video_streams: {
                    if let Some(tlv::TlvItemValue::List(l)) = nested_item.get(&[9]) {
                        let mut items = Vec::new();
                        for list_item in l {
                            items.push(VideoStream {
                video_stream_name: list_item.get_string_owned(&[0]),
                video_stream_id: list_item.get_int(&[1]).map(|v| v as u8),
                            });
                        }
                        Some(items)
                    } else {
                        None
                    }
                },
                audio_streams: {
                    if let Some(tlv::TlvItemValue::List(l)) = nested_item.get(&[10]) {
                        let mut items = Vec::new();
                        for list_item in l {
                            items.push(AudioStream {
                audio_stream_name: list_item.get_string_owned(&[0]),
                audio_stream_id: list_item.get_int(&[1]).map(|v| v as u8),
                            });
                        }
                        Some(items)
                    } else {
                        None
                    }
                },
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
        })
    } else {
        Err(anyhow::anyhow!("Expected struct fields"))
    }
}

/// Decode FindTransportResponse command response (07)
pub fn decode_find_transport_response(inp: &tlv::TlvItemValue) -> anyhow::Result<FindTransportResponse> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(FindTransportResponse {
                transport_configurations: {
                    if let Some(tlv::TlvItemValue::List(l)) = item.get(&[0]) {
                        let mut items = Vec::new();
                        for list_item in l {
                            items.push(TransportConfiguration {
                connection_id: list_item.get_int(&[0]).map(|v| v as u8),
                transport_status: list_item.get_int(&[1]).and_then(|v| TransportStatus::from_u8(v as u8)),
                transport_options: {
                    if let Some(nested_tlv) = list_item.get(&[2]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 2, value: nested_tlv.clone() };
                            Some(TransportOptions {
                stream_usage: nested_item.get_int(&[0]).map(|v| v as u8),
                video_stream_id: nested_item.get_int(&[1]).map(|v| v as u8),
                audio_stream_id: nested_item.get_int(&[2]).map(|v| v as u8),
                tls_endpoint_id: nested_item.get_int(&[3]).map(|v| v as u8),
                url: nested_item.get_string_owned(&[4]),
                trigger_options: {
                    if let Some(nested_tlv) = nested_item.get(&[5]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 5, value: nested_tlv.clone() };
                            Some(TransportTriggerOptions {
                trigger_type: nested_item.get_int(&[0]).and_then(|v| TransportTriggerType::from_u8(v as u8)),
                motion_zones: {
                    if let Some(tlv::TlvItemValue::List(l)) = nested_item.get(&[1]) {
                        let mut items = Vec::new();
                        for list_item in l {
                            items.push(TransportZoneOptions {
                zone: list_item.get_int(&[0]).map(|v| v as u8),
                sensitivity: list_item.get_int(&[1]).map(|v| v as u8),
                            });
                        }
                        Some(items)
                    } else {
                        None
                    }
                },
                motion_sensitivity: nested_item.get_int(&[2]).map(|v| v as u8),
                motion_time_control: {
                    if let Some(nested_tlv) = nested_item.get(&[3]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 3, value: nested_tlv.clone() };
                            Some(TransportMotionTriggerTimeControl {
                initial_duration: nested_item.get_int(&[0]).map(|v| v as u16),
                augmentation_duration: nested_item.get_int(&[1]).map(|v| v as u16),
                max_duration: nested_item.get_int(&[2]).map(|v| v as u32),
                blind_duration: nested_item.get_int(&[3]).map(|v| v as u16),
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
                max_pre_roll_len: nested_item.get_int(&[4]).map(|v| v as u16),
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
                ingest_method: nested_item.get_int(&[6]).and_then(|v| IngestMethods::from_u8(v as u8)),
                container_options: {
                    if let Some(nested_tlv) = nested_item.get(&[7]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 7, value: nested_tlv.clone() };
                            Some(ContainerOptions {
                container_type: nested_item.get_int(&[0]).and_then(|v| ContainerFormat::from_u8(v as u8)),
                cmaf_container_options: {
                    if let Some(nested_tlv) = nested_item.get(&[1]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 1, value: nested_tlv.clone() };
                            Some(CMAFContainerOptions {
                cmaf_interface: nested_item.get_int(&[0]).and_then(|v| CMAFInterface::from_u8(v as u8)),
                segment_duration: nested_item.get_int(&[1]).map(|v| v as u16),
                chunk_duration: nested_item.get_int(&[2]).map(|v| v as u16),
                session_group: nested_item.get_int(&[3]).map(|v| v as u8),
                track_name: nested_item.get_string_owned(&[4]),
                cenc_key: nested_item.get_octet_string_owned(&[5]),
                cenc_key_id: nested_item.get_octet_string_owned(&[6]),
                metadata_enabled: nested_item.get_bool(&[7]),
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
                expiry_time: nested_item.get_int(&[8]),
                video_streams: {
                    if let Some(tlv::TlvItemValue::List(l)) = nested_item.get(&[9]) {
                        let mut items = Vec::new();
                        for list_item in l {
                            items.push(VideoStream {
                video_stream_name: list_item.get_string_owned(&[0]),
                video_stream_id: list_item.get_int(&[1]).map(|v| v as u8),
                            });
                        }
                        Some(items)
                    } else {
                        None
                    }
                },
                audio_streams: {
                    if let Some(tlv::TlvItemValue::List(l)) = nested_item.get(&[10]) {
                        let mut items = Vec::new();
                        for list_item in l {
                            items.push(AudioStream {
                audio_stream_name: list_item.get_string_owned(&[0]),
                audio_stream_id: list_item.get_int(&[1]).map(|v| v as u8),
                            });
                        }
                        Some(items)
                    } else {
                        None
                    }
                },
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
                            });
                        }
                        Some(items)
                    } else {
                        None
                    }
                },
        })
    } else {
        Err(anyhow::anyhow!("Expected struct fields"))
    }
}

#[derive(Debug, serde::Serialize)]
pub struct PushTransportBeginEvent {
    pub connection_id: Option<u8>,
    pub trigger_type: Option<TransportTriggerType>,
    pub activation_reason: Option<TriggerActivationReason>,
    pub container_type: Option<ContainerFormat>,
    pub cmaf_session_number: Option<u64>,
    #[serde(serialize_with = "serialize_opt_bytes_as_hex")]
    pub vendor_specific_context: Option<Vec<u8>>,
}

#[derive(Debug, serde::Serialize)]
pub struct PushTransportEndEvent {
    pub connection_id: Option<u8>,
    pub container_type: Option<ContainerFormat>,
    pub cmaf_session_number: Option<u64>,
}

// Event decoders

/// Decode PushTransportBegin event (0x00, priority: info)
pub fn decode_push_transport_begin_event(inp: &tlv::TlvItemValue) -> anyhow::Result<PushTransportBeginEvent> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(PushTransportBeginEvent {
                                connection_id: item.get_int(&[0]).map(|v| v as u8),
                                trigger_type: item.get_int(&[1]).and_then(|v| TransportTriggerType::from_u8(v as u8)),
                                activation_reason: item.get_int(&[2]).and_then(|v| TriggerActivationReason::from_u8(v as u8)),
                                container_type: item.get_int(&[3]).and_then(|v| ContainerFormat::from_u8(v as u8)),
                                cmaf_session_number: item.get_int(&[4]),
                                vendor_specific_context: item.get_octet_string_owned(&[5]),
        })
    } else {
        Err(anyhow::anyhow!("Expected struct fields"))
    }
}

/// Decode PushTransportEnd event (0x01, priority: info)
pub fn decode_push_transport_end_event(inp: &tlv::TlvItemValue) -> anyhow::Result<PushTransportEndEvent> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(PushTransportEndEvent {
                                connection_id: item.get_int(&[0]).map(|v| v as u8),
                                container_type: item.get_int(&[1]).and_then(|v| ContainerFormat::from_u8(v as u8)),
                                cmaf_session_number: item.get_int(&[2]),
        })
    } else {
        Err(anyhow::anyhow!("Expected struct fields"))
    }
}

