//! Matter TLV encoders and decoders for General Diagnostics Cluster
//! Cluster ID: 0x0033
//!
//! This file is automatically generated from DiagnosticsGeneral.xml

use crate::tlv;
use anyhow;
use serde_json;


// Import serialization helpers for octet strings
use crate::clusters::helpers::{serialize_opt_bytes_as_hex};

// Enum definitions

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum BootReason {
    /// The Node is unable to identify the Power-On reason as one of the other provided enumeration values.
    Unspecified = 0,
    /// The Node has booted as the result of physical interaction with the device resulting in a reboot.
    Poweronreboot = 1,
    /// The Node has rebooted as the result of a brown-out of the Node's power supply.
    Brownoutreset = 2,
    /// The Node has rebooted as the result of a software watchdog timer.
    Softwarewatchdogreset = 3,
    /// The Node has rebooted as the result of a hardware watchdog timer.
    Hardwarewatchdogreset = 4,
    /// The Node has rebooted as the result of a completed software update.
    Softwareupdatecompleted = 5,
    /// The Node has rebooted as the result of a software initiated reboot.
    Softwarereset = 6,
}

impl BootReason {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(BootReason::Unspecified),
            1 => Some(BootReason::Poweronreboot),
            2 => Some(BootReason::Brownoutreset),
            3 => Some(BootReason::Softwarewatchdogreset),
            4 => Some(BootReason::Hardwarewatchdogreset),
            5 => Some(BootReason::Softwareupdatecompleted),
            6 => Some(BootReason::Softwarereset),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<BootReason> for u8 {
    fn from(val: BootReason) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum HardwareFault {
    /// The Node has encountered an unspecified fault.
    Unspecified = 0,
    /// The Node has encountered a fault with at least one of its radios.
    Radio = 1,
    /// The Node has encountered a fault with at least one of its sensors.
    Sensor = 2,
    /// The Node has encountered an over-temperature fault that is resettable.
    Resettableovertemp = 3,
    /// The Node has encountered an over-temperature fault that is not resettable.
    Nonresettableovertemp = 4,
    /// The Node has encountered a fault with at least one of its power sources.
    Powersource = 5,
    /// The Node has encountered a fault with at least one of its visual displays.
    Visualdisplayfault = 6,
    /// The Node has encountered a fault with at least one of its audio outputs.
    Audiooutputfault = 7,
    /// The Node has encountered a fault with at least one of its user interfaces.
    Userinterfacefault = 8,
    /// The Node has encountered a fault with its non-volatile memory.
    Nonvolatilememoryerror = 9,
    /// The Node has encountered disallowed physical tampering.
    Tamperdetected = 10,
}

impl HardwareFault {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(HardwareFault::Unspecified),
            1 => Some(HardwareFault::Radio),
            2 => Some(HardwareFault::Sensor),
            3 => Some(HardwareFault::Resettableovertemp),
            4 => Some(HardwareFault::Nonresettableovertemp),
            5 => Some(HardwareFault::Powersource),
            6 => Some(HardwareFault::Visualdisplayfault),
            7 => Some(HardwareFault::Audiooutputfault),
            8 => Some(HardwareFault::Userinterfacefault),
            9 => Some(HardwareFault::Nonvolatilememoryerror),
            10 => Some(HardwareFault::Tamperdetected),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<HardwareFault> for u8 {
    fn from(val: HardwareFault) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum InterfaceType {
    /// Indicates an interface of an unspecified type.
    Unspecified = 0,
    /// Indicates a Wi-Fi interface.
    Wifi = 1,
    /// Indicates a Ethernet interface.
    Ethernet = 2,
    /// Indicates a Cellular interface.
    Cellular = 3,
    /// Indicates a Thread interface.
    Thread = 4,
}

impl InterfaceType {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(InterfaceType::Unspecified),
            1 => Some(InterfaceType::Wifi),
            2 => Some(InterfaceType::Ethernet),
            3 => Some(InterfaceType::Cellular),
            4 => Some(InterfaceType::Thread),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<InterfaceType> for u8 {
    fn from(val: InterfaceType) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum NetworkFault {
    /// The Node has encountered an unspecified fault.
    Unspecified = 0,
    /// The Node has encountered a network fault as a result of a hardware failure.
    Hardwarefailure = 1,
    /// The Node has encountered a network fault as a result of a jammed network.
    Networkjammed = 2,
    /// The Node has encountered a network fault as a result of a failure to establish a connection.
    Connectionfailed = 3,
}

impl NetworkFault {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(NetworkFault::Unspecified),
            1 => Some(NetworkFault::Hardwarefailure),
            2 => Some(NetworkFault::Networkjammed),
            3 => Some(NetworkFault::Connectionfailed),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<NetworkFault> for u8 {
    fn from(val: NetworkFault) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum RadioFault {
    /// The Node has encountered an unspecified radio fault.
    Unspecified = 0,
    /// The Node has encountered a fault with its Wi-Fi radio.
    Wififault = 1,
    /// The Node has encountered a fault with its cellular radio.
    Cellularfault = 2,
    /// The Node has encountered a fault with its 802.15.4 radio.
    Threadfault = 3,
    /// The Node has encountered a fault with its NFC radio.
    Nfcfault = 4,
    /// The Node has encountered a fault with its BLE radio.
    Blefault = 5,
    /// The Node has encountered a fault with its Ethernet controller.
    Ethernetfault = 6,
}

impl RadioFault {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(RadioFault::Unspecified),
            1 => Some(RadioFault::Wififault),
            2 => Some(RadioFault::Cellularfault),
            3 => Some(RadioFault::Threadfault),
            4 => Some(RadioFault::Nfcfault),
            5 => Some(RadioFault::Blefault),
            6 => Some(RadioFault::Ethernetfault),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<RadioFault> for u8 {
    fn from(val: RadioFault) -> Self {
        val as u8
    }
}

// Struct definitions

#[derive(Debug, serde::Serialize)]
pub struct NetworkInterface {
    pub name: Option<String>,
    pub is_operational: Option<bool>,
    pub off_premise_services_reachable_i_pv4: Option<bool>,
    pub off_premise_services_reachable_i_pv6: Option<bool>,
    pub hardware_address: Option<u8>,
    pub i_pv4_addresses: Option<Vec<u8>>,
    pub i_pv6_addresses: Option<Vec<u8>>,
    pub type_: Option<InterfaceType>,
}

// Command encoders

/// Encode TestEventTrigger command (0x00)
pub fn encode_test_event_trigger(enable_key: Vec<u8>, event_trigger: u64) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::OctetString(enable_key)).into(),
        (1, tlv::TlvItemValueEnc::UInt64(event_trigger)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode PayloadTestRequest command (0x03)
pub fn encode_payload_test_request(enable_key: Vec<u8>, value: u8, count: u16) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::OctetString(enable_key)).into(),
        (1, tlv::TlvItemValueEnc::UInt8(value)).into(),
        (2, tlv::TlvItemValueEnc::UInt16(count)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

// Attribute decoders

/// Decode NetworkInterfaces attribute (0x0000)
pub fn decode_network_interfaces(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<NetworkInterface>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(NetworkInterface {
                name: item.get_string_owned(&[0]),
                is_operational: item.get_bool(&[1]),
                off_premise_services_reachable_i_pv4: item.get_bool(&[2]),
                off_premise_services_reachable_i_pv6: item.get_bool(&[3]),
                hardware_address: item.get_int(&[4]).map(|v| v as u8),
                i_pv4_addresses: {
                    if let Some(tlv::TlvItemValue::List(l)) = item.get(&[5]) {
                        let items: Vec<u8> = l.iter().filter_map(|e| { if let tlv::TlvItemValue::Int(v) = &e.value { Some(*v as u8) } else { None } }).collect();
                        Some(items)
                    } else {
                        None
                    }
                },
                i_pv6_addresses: {
                    if let Some(tlv::TlvItemValue::List(l)) = item.get(&[6]) {
                        let items: Vec<u8> = l.iter().filter_map(|e| { if let tlv::TlvItemValue::Int(v) = &e.value { Some(*v as u8) } else { None } }).collect();
                        Some(items)
                    } else {
                        None
                    }
                },
                type_: item.get_int(&[7]).and_then(|v| InterfaceType::from_u8(v as u8)),
            });
        }
    }
    Ok(res)
}

/// Decode RebootCount attribute (0x0001)
pub fn decode_reboot_count(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected UInt16"))
    }
}

/// Decode UpTime attribute (0x0002)
pub fn decode_up_time(inp: &tlv::TlvItemValue) -> anyhow::Result<u64> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected UInt64"))
    }
}

/// Decode TotalOperationalHours attribute (0x0003)
pub fn decode_total_operational_hours(inp: &tlv::TlvItemValue) -> anyhow::Result<u32> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u32)
    } else {
        Err(anyhow::anyhow!("Expected UInt32"))
    }
}

/// Decode BootReason attribute (0x0004)
pub fn decode_boot_reason(inp: &tlv::TlvItemValue) -> anyhow::Result<BootReason> {
    if let tlv::TlvItemValue::Int(v) = inp {
        BootReason::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode ActiveHardwareFaults attribute (0x0005)
pub fn decode_active_hardware_faults(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<HardwareFault>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            if let tlv::TlvItemValue::Int(i) = &item.value {
                if let Some(enum_val) = HardwareFault::from_u8(*i as u8) {
                    res.push(enum_val);
                }
            }
        }
    }
    Ok(res)
}

/// Decode ActiveRadioFaults attribute (0x0006)
pub fn decode_active_radio_faults(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<RadioFault>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            if let tlv::TlvItemValue::Int(i) = &item.value {
                if let Some(enum_val) = RadioFault::from_u8(*i as u8) {
                    res.push(enum_val);
                }
            }
        }
    }
    Ok(res)
}

/// Decode ActiveNetworkFaults attribute (0x0007)
pub fn decode_active_network_faults(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<NetworkFault>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            if let tlv::TlvItemValue::Int(i) = &item.value {
                if let Some(enum_val) = NetworkFault::from_u8(*i as u8) {
                    res.push(enum_val);
                }
            }
        }
    }
    Ok(res)
}

/// Decode TestEventTriggersEnabled attribute (0x0008)
pub fn decode_test_event_triggers_enabled(inp: &tlv::TlvItemValue) -> anyhow::Result<bool> {
    if let tlv::TlvItemValue::Bool(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected Bool"))
    }
}

/// Decode DoNotUse attribute (0x0009)
pub fn decode_do_not_use(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}


// JSON dispatcher function

/// Decode attribute value and return as JSON string
///
/// # Parameters
/// * `cluster_id` - The cluster identifier
/// * `attribute_id` - The attribute identifier
/// * `tlv_value` - The TLV value to decode
///
/// # Returns
/// JSON string representation of the decoded value or error
pub fn decode_attribute_json(cluster_id: u32, attribute_id: u32, tlv_value: &crate::tlv::TlvItemValue) -> String {
    // Verify this is the correct cluster
    if cluster_id != 0x0033 {
        return format!("{{\"error\": \"Invalid cluster ID. Expected 0x0033, got {}\"}}", cluster_id);
    }

    match attribute_id {
        0x0000 => {
            match decode_network_interfaces(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0001 => {
            match decode_reboot_count(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0002 => {
            match decode_up_time(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0003 => {
            match decode_total_operational_hours(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0004 => {
            match decode_boot_reason(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0005 => {
            match decode_active_hardware_faults(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0006 => {
            match decode_active_radio_faults(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0007 => {
            match decode_active_network_faults(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0008 => {
            match decode_test_event_triggers_enabled(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0009 => {
            match decode_do_not_use(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        _ => format!("{{\"error\": \"Unknown attribute ID: {}\"}}", attribute_id),
    }
}

/// Get list of all attributes supported by this cluster
///
/// # Returns
/// Vector of tuples containing (attribute_id, attribute_name)
pub fn get_attribute_list() -> Vec<(u32, &'static str)> {
    vec![
        (0x0000, "NetworkInterfaces"),
        (0x0001, "RebootCount"),
        (0x0002, "UpTime"),
        (0x0003, "TotalOperationalHours"),
        (0x0004, "BootReason"),
        (0x0005, "ActiveHardwareFaults"),
        (0x0006, "ActiveRadioFaults"),
        (0x0007, "ActiveNetworkFaults"),
        (0x0008, "TestEventTriggersEnabled"),
        (0x0009, "DoNotUse"),
    ]
}

#[derive(Debug, serde::Serialize)]
pub struct TimeSnapshotResponse {
    pub system_time_ms: Option<u8>,
    pub posix_time_ms: Option<u8>,
}

#[derive(Debug, serde::Serialize)]
pub struct PayloadTestResponse {
    #[serde(serialize_with = "serialize_opt_bytes_as_hex")]
    pub payload: Option<Vec<u8>>,
}

// Command response decoders

/// Decode TimeSnapshotResponse command response (02)
pub fn decode_time_snapshot_response(inp: &tlv::TlvItemValue) -> anyhow::Result<TimeSnapshotResponse> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(TimeSnapshotResponse {
                system_time_ms: item.get_int(&[0]).map(|v| v as u8),
                posix_time_ms: item.get_int(&[1]).map(|v| v as u8),
        })
    } else {
        Err(anyhow::anyhow!("Expected struct fields"))
    }
}

/// Decode PayloadTestResponse command response (04)
pub fn decode_payload_test_response(inp: &tlv::TlvItemValue) -> anyhow::Result<PayloadTestResponse> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(PayloadTestResponse {
                payload: item.get_octet_string_owned(&[0]),
        })
    } else {
        Err(anyhow::anyhow!("Expected struct fields"))
    }
}

#[derive(Debug, serde::Serialize)]
pub struct HardwareFaultChangeEvent {
    pub current: Option<Vec<HardwareFault>>,
    pub previous: Option<Vec<HardwareFault>>,
}

#[derive(Debug, serde::Serialize)]
pub struct RadioFaultChangeEvent {
    pub current: Option<Vec<RadioFault>>,
    pub previous: Option<Vec<RadioFault>>,
}

#[derive(Debug, serde::Serialize)]
pub struct NetworkFaultChangeEvent {
    pub current: Option<Vec<NetworkFault>>,
    pub previous: Option<Vec<NetworkFault>>,
}

#[derive(Debug, serde::Serialize)]
pub struct BootReasonEvent {
    pub boot_reason: Option<BootReason>,
}

// Event decoders

/// Decode HardwareFaultChange event (0x00, priority: critical)
pub fn decode_hardware_fault_change_event(inp: &tlv::TlvItemValue) -> anyhow::Result<HardwareFaultChangeEvent> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(HardwareFaultChangeEvent {
                                current: {
                    if let Some(tlv::TlvItemValue::List(l)) = item.get(&[0]) {
                        let items: Vec<HardwareFault> = l.iter().filter_map(|e| { if let tlv::TlvItemValue::Int(v) = &e.value { HardwareFault::from_u8(*v as u8) } else { None } }).collect();
                        Some(items)
                    } else {
                        None
                    }
                },
                                previous: {
                    if let Some(tlv::TlvItemValue::List(l)) = item.get(&[1]) {
                        let items: Vec<HardwareFault> = l.iter().filter_map(|e| { if let tlv::TlvItemValue::Int(v) = &e.value { HardwareFault::from_u8(*v as u8) } else { None } }).collect();
                        Some(items)
                    } else {
                        None
                    }
                },
        })
    } else {
        Err(anyhow::anyhow!("Expected struct fields"))
    }
}

/// Decode RadioFaultChange event (0x01, priority: critical)
pub fn decode_radio_fault_change_event(inp: &tlv::TlvItemValue) -> anyhow::Result<RadioFaultChangeEvent> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(RadioFaultChangeEvent {
                                current: {
                    if let Some(tlv::TlvItemValue::List(l)) = item.get(&[0]) {
                        let items: Vec<RadioFault> = l.iter().filter_map(|e| { if let tlv::TlvItemValue::Int(v) = &e.value { RadioFault::from_u8(*v as u8) } else { None } }).collect();
                        Some(items)
                    } else {
                        None
                    }
                },
                                previous: {
                    if let Some(tlv::TlvItemValue::List(l)) = item.get(&[1]) {
                        let items: Vec<RadioFault> = l.iter().filter_map(|e| { if let tlv::TlvItemValue::Int(v) = &e.value { RadioFault::from_u8(*v as u8) } else { None } }).collect();
                        Some(items)
                    } else {
                        None
                    }
                },
        })
    } else {
        Err(anyhow::anyhow!("Expected struct fields"))
    }
}

/// Decode NetworkFaultChange event (0x02, priority: critical)
pub fn decode_network_fault_change_event(inp: &tlv::TlvItemValue) -> anyhow::Result<NetworkFaultChangeEvent> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(NetworkFaultChangeEvent {
                                current: {
                    if let Some(tlv::TlvItemValue::List(l)) = item.get(&[0]) {
                        let items: Vec<NetworkFault> = l.iter().filter_map(|e| { if let tlv::TlvItemValue::Int(v) = &e.value { NetworkFault::from_u8(*v as u8) } else { None } }).collect();
                        Some(items)
                    } else {
                        None
                    }
                },
                                previous: {
                    if let Some(tlv::TlvItemValue::List(l)) = item.get(&[1]) {
                        let items: Vec<NetworkFault> = l.iter().filter_map(|e| { if let tlv::TlvItemValue::Int(v) = &e.value { NetworkFault::from_u8(*v as u8) } else { None } }).collect();
                        Some(items)
                    } else {
                        None
                    }
                },
        })
    } else {
        Err(anyhow::anyhow!("Expected struct fields"))
    }
}

/// Decode BootReason event (0x03, priority: critical)
pub fn decode_boot_reason_event(inp: &tlv::TlvItemValue) -> anyhow::Result<BootReasonEvent> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(BootReasonEvent {
                                boot_reason: item.get_int(&[0]).and_then(|v| BootReason::from_u8(v as u8)),
        })
    } else {
        Err(anyhow::anyhow!("Expected struct fields"))
    }
}

