//! Generated Matter TLV encoders and decoders for Media Playback Cluster
//! Cluster ID: 0x0506
//!
//! This file is automatically generated from MediaPlayback.xml

use crate::tlv;
use anyhow;
use serde_json;


// Enum definitions

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum Characteristic {
    /// Textual information meant for display when no other text representation is selected. It is used to clarify dialogue, alternate languages, texted graphics or location/person IDs that are not otherwise covered in the dubbed/localized audio.
    Forcedsubtitles = 0,
    /// Textual or audio media component containing a textual description (intended for audio synthesis) or an audio description describing a visual component
    Describesvideo = 1,
    /// Simplified or reduced captions as specified in [United States Code Title 47 CFR 79.103(c)(9)].
    Easytoread = 2,
    /// A media characteristic that indicates that a track selection option includes frame-based content.
    Framebased = 3,
    /// Main media component(s) which is/are intended for presentation if no other information is provided
    Mainprogram = 4,
    /// A media characteristic that indicates that a track or media selection option contains original content.
    Originalcontent = 5,
    /// A media characteristic that indicates that a track or media selection option contains a language translation and verbal interpretation of spoken dialog.
    Voiceovertranslation = 6,
    /// Textual media component containing transcriptions of spoken dialog and auditory cues such as sound effects and music for the hearing impaired.
    Caption = 7,
    /// Textual transcriptions of spoken dialog.
    Subtitle = 8,
    /// Textual media component containing transcriptions of spoken dialog and auditory cues such as sound effects and music for the hearing impaired.
    Alternate = 9,
    /// Media content component that is supplementary to a media content component of a different media component type.
    Supplementary = 10,
    /// Experience that contains a commentary (e.g. director’s commentary) (typically audio)
    Commentary = 11,
    /// Experience that contains an element that is presented in a different language from the original (e.g. dubbed audio, translated captions)
    Dubbedtranslation = 12,
    /// Textual or audio media component containing a textual description (intended for audio synthesis) or an audio description describing a visual component
    Description = 13,
    /// Media component containing information intended to be processed by application specific elements.
    Metadata = 14,
    /// Experience containing an element for improved intelligibility of the dialogue.
    Enhancedaudiointelligibility = 15,
    /// Experience that provides information, about a current emergency, that is intended to enable the protection of life, health, safety, and property, and may also include critical details regarding the emergency and how to respond to the emergency.
    Emergency = 16,
    /// Textual representation of a songs’ lyrics, usually in the same language as the associated song as specified in [SMPTE ST 2067-2].
    Karaoke = 17,
}

impl Characteristic {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(Characteristic::Forcedsubtitles),
            1 => Some(Characteristic::Describesvideo),
            2 => Some(Characteristic::Easytoread),
            3 => Some(Characteristic::Framebased),
            4 => Some(Characteristic::Mainprogram),
            5 => Some(Characteristic::Originalcontent),
            6 => Some(Characteristic::Voiceovertranslation),
            7 => Some(Characteristic::Caption),
            8 => Some(Characteristic::Subtitle),
            9 => Some(Characteristic::Alternate),
            10 => Some(Characteristic::Supplementary),
            11 => Some(Characteristic::Commentary),
            12 => Some(Characteristic::Dubbedtranslation),
            13 => Some(Characteristic::Description),
            14 => Some(Characteristic::Metadata),
            15 => Some(Characteristic::Enhancedaudiointelligibility),
            16 => Some(Characteristic::Emergency),
            17 => Some(Characteristic::Karaoke),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<Characteristic> for u8 {
    fn from(val: Characteristic) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum PlaybackState {
    /// Media is currently playing (includes FF and REW)
    Playing = 0,
    /// Media is currently paused
    Paused = 1,
    /// Media is not currently playing
    Notplaying = 2,
    /// Media is not currently buffering and playback will start when buffer has been filled
    Buffering = 3,
}

impl PlaybackState {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(PlaybackState::Playing),
            1 => Some(PlaybackState::Paused),
            2 => Some(PlaybackState::Notplaying),
            3 => Some(PlaybackState::Buffering),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<PlaybackState> for u8 {
    fn from(val: PlaybackState) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum Status {
    /// Succeeded
    Success = 0,
    /// Requested playback command is invalid in the current playback state.
    Invalidstateforcommand = 1,
    /// Requested playback command is not allowed in the current playback state. For example, attempting to fast-forward during a commercial might return NotAllowed.
    Notallowed = 2,
    /// This endpoint is not active for playback.
    Notactive = 3,
    /// The FastForward or Rewind Command was issued but the media is already playing back at the fastest speed supported by the server in the respective direction.
    Speedoutofrange = 4,
    /// The Seek Command was issued with a value of position outside of the allowed seek range of the media.
    Seekoutofrange = 5,
}

impl Status {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(Status::Success),
            1 => Some(Status::Invalidstateforcommand),
            2 => Some(Status::Notallowed),
            3 => Some(Status::Notactive),
            4 => Some(Status::Speedoutofrange),
            5 => Some(Status::Seekoutofrange),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<Status> for u8 {
    fn from(val: Status) -> Self {
        val as u8
    }
}

// Struct definitions

#[derive(Debug, serde::Serialize)]
pub struct PlaybackPosition {
    pub updated_at: Option<u64>,
    pub position: Option<u64>,
}

#[derive(Debug, serde::Serialize)]
pub struct TrackAttributes {
    pub language_code: Option<String>,
    pub characteristics: Option<Vec<Characteristic>>,
    pub display_name: Option<String>,
}

#[derive(Debug, serde::Serialize)]
pub struct Track {
    pub id: Option<String>,
    pub track_attributes: Option<TrackAttributes>,
}

// Command encoders

/// Encode Rewind command (0x06)
pub fn encode_rewind(audio_advance_unmuted: bool) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::Bool(audio_advance_unmuted)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode FastForward command (0x07)
pub fn encode_fast_forward(audio_advance_unmuted: bool) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::Bool(audio_advance_unmuted)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SkipForward command (0x08)
pub fn encode_skip_forward(delta_position_milliseconds: u64) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt64(delta_position_milliseconds)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SkipBackward command (0x09)
pub fn encode_skip_backward(delta_position_milliseconds: u64) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt64(delta_position_milliseconds)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode Seek command (0x0B)
pub fn encode_seek(position: u64) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt64(position)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode ActivateAudioTrack command (0x0C)
pub fn encode_activate_audio_track(track_id: String, audio_output_index: Option<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::String(track_id)).into(),
        (1, tlv::TlvItemValueEnc::UInt8(audio_output_index.unwrap_or(0))).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode ActivateTextTrack command (0x0D)
pub fn encode_activate_text_track(track_id: String) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::String(track_id)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

// Attribute decoders

/// Decode CurrentState attribute (0x0000)
pub fn decode_current_state(inp: &tlv::TlvItemValue) -> anyhow::Result<PlaybackState> {
    if let tlv::TlvItemValue::Int(v) = inp {
        PlaybackState::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode StartTime attribute (0x0001)
pub fn decode_start_time(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u64>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v))
    } else {
        Ok(None)
    }
}

/// Decode Duration attribute (0x0002)
pub fn decode_duration(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u64>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v))
    } else {
        Ok(None)
    }
}

/// Decode SampledPosition attribute (0x0003)
pub fn decode_sampled_position(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<PlaybackPosition>> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        // Struct with fields
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(Some(PlaybackPosition {
                updated_at: item.get_int(&[0]),
                position: item.get_int(&[1]),
        }))
    //} else if let tlv::TlvItemValue::Null = inp {
    //    // Null value for nullable struct
    //    Ok(None)
    } else {
    Ok(None)
    //    Err(anyhow::anyhow!("Expected struct fields or null"))
    }
}

/// Decode PlaybackSpeed attribute (0x0004)
pub fn decode_playback_speed(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode SeekRangeEnd attribute (0x0005)
pub fn decode_seek_range_end(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u64>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v))
    } else {
        Ok(None)
    }
}

/// Decode SeekRangeStart attribute (0x0006)
pub fn decode_seek_range_start(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u64>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v))
    } else {
        Ok(None)
    }
}

/// Decode ActiveAudioTrack attribute (0x0007)
pub fn decode_active_audio_track(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<Track>> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        // Struct with fields
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(Some(Track {
                id: item.get_string_owned(&[0]),
                track_attributes: {
                    if let Some(nested_tlv) = item.get(&[1]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 1, value: nested_tlv.clone() };
                            Some(TrackAttributes {
                language_code: nested_item.get_string_owned(&[0]),
                characteristics: {
                    if let Some(tlv::TlvItemValue::List(l)) = nested_item.get(&[1]) {
                        let items: Vec<Characteristic> = l.iter().filter_map(|e| { if let tlv::TlvItemValue::Int(v) = &e.value { Characteristic::from_u8(*v as u8) } else { None } }).collect();
                        Some(items)
                    } else {
                        None
                    }
                },
                display_name: nested_item.get_string_owned(&[2]),
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
        }))
    //} else if let tlv::TlvItemValue::Null = inp {
    //    // Null value for nullable struct
    //    Ok(None)
    } else {
    Ok(None)
    //    Err(anyhow::anyhow!("Expected struct fields or null"))
    }
}

/// Decode AvailableAudioTracks attribute (0x0008)
pub fn decode_available_audio_tracks(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<Track>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(Track {
                id: item.get_string_owned(&[0]),
                track_attributes: {
                    if let Some(nested_tlv) = item.get(&[1]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 1, value: nested_tlv.clone() };
                            Some(TrackAttributes {
                language_code: nested_item.get_string_owned(&[0]),
                characteristics: {
                    if let Some(tlv::TlvItemValue::List(l)) = nested_item.get(&[1]) {
                        let items: Vec<Characteristic> = l.iter().filter_map(|e| { if let tlv::TlvItemValue::Int(v) = &e.value { Characteristic::from_u8(*v as u8) } else { None } }).collect();
                        Some(items)
                    } else {
                        None
                    }
                },
                display_name: nested_item.get_string_owned(&[2]),
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
            });
        }
    }
    Ok(res)
}

/// Decode ActiveTextTrack attribute (0x0009)
pub fn decode_active_text_track(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<Track>> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        // Struct with fields
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(Some(Track {
                id: item.get_string_owned(&[0]),
                track_attributes: {
                    if let Some(nested_tlv) = item.get(&[1]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 1, value: nested_tlv.clone() };
                            Some(TrackAttributes {
                language_code: nested_item.get_string_owned(&[0]),
                characteristics: {
                    if let Some(tlv::TlvItemValue::List(l)) = nested_item.get(&[1]) {
                        let items: Vec<Characteristic> = l.iter().filter_map(|e| { if let tlv::TlvItemValue::Int(v) = &e.value { Characteristic::from_u8(*v as u8) } else { None } }).collect();
                        Some(items)
                    } else {
                        None
                    }
                },
                display_name: nested_item.get_string_owned(&[2]),
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
        }))
    //} else if let tlv::TlvItemValue::Null = inp {
    //    // Null value for nullable struct
    //    Ok(None)
    } else {
    Ok(None)
    //    Err(anyhow::anyhow!("Expected struct fields or null"))
    }
}

/// Decode AvailableTextTracks attribute (0x000A)
pub fn decode_available_text_tracks(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<Track>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(Track {
                id: item.get_string_owned(&[0]),
                track_attributes: {
                    if let Some(nested_tlv) = item.get(&[1]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 1, value: nested_tlv.clone() };
                            Some(TrackAttributes {
                language_code: nested_item.get_string_owned(&[0]),
                characteristics: {
                    if let Some(tlv::TlvItemValue::List(l)) = nested_item.get(&[1]) {
                        let items: Vec<Characteristic> = l.iter().filter_map(|e| { if let tlv::TlvItemValue::Int(v) = &e.value { Characteristic::from_u8(*v as u8) } else { None } }).collect();
                        Some(items)
                    } else {
                        None
                    }
                },
                display_name: nested_item.get_string_owned(&[2]),
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
            });
        }
    }
    Ok(res)
}


// JSON dispatcher function

/// Decode attribute value and return as JSON string
/// 
/// # Parameters
/// * `cluster_id` - The cluster identifier
/// * `attribute_id` - The attribute identifier
/// * `tlv_value` - The TLV value to decode
/// 
/// # Returns
/// JSON string representation of the decoded value or error
pub fn decode_attribute_json(cluster_id: u32, attribute_id: u32, tlv_value: &crate::tlv::TlvItemValue) -> String {
    // Verify this is the correct cluster
    if cluster_id != 0x0506 {
        return format!("{{\"error\": \"Invalid cluster ID. Expected 0x0506, got {}\"}}", cluster_id);
    }
    
    match attribute_id {
        0x0000 => {
            match decode_current_state(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0001 => {
            match decode_start_time(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0002 => {
            match decode_duration(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0003 => {
            match decode_sampled_position(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0004 => {
            match decode_playback_speed(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0005 => {
            match decode_seek_range_end(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0006 => {
            match decode_seek_range_start(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0007 => {
            match decode_active_audio_track(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0008 => {
            match decode_available_audio_tracks(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0009 => {
            match decode_active_text_track(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000A => {
            match decode_available_text_tracks(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        _ => format!("{{\"error\": \"Unknown attribute ID: {}\"}}", attribute_id),
    }
}

/// Get list of all attributes supported by this cluster
/// 
/// # Returns
/// Vector of tuples containing (attribute_id, attribute_name)
pub fn get_attribute_list() -> Vec<(u32, &'static str)> {
    vec![
        (0x0000, "CurrentState"),
        (0x0001, "StartTime"),
        (0x0002, "Duration"),
        (0x0003, "SampledPosition"),
        (0x0004, "PlaybackSpeed"),
        (0x0005, "SeekRangeEnd"),
        (0x0006, "SeekRangeStart"),
        (0x0007, "ActiveAudioTrack"),
        (0x0008, "AvailableAudioTracks"),
        (0x0009, "ActiveTextTrack"),
        (0x000A, "AvailableTextTracks"),
    ]
}

