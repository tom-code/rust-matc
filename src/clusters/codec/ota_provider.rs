//! Generated Matter TLV encoders and decoders for OTA Software Update Provider Cluster
//! Cluster ID: 0x0029
//!
//! This file is automatically generated from OTAProvider.xml

use crate::tlv;
use anyhow;


// Enum definitions

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ApplyUpdateAction {
    /// Apply the update.
    Proceed = 0,
    /// Wait at least the given delay time.
    Awaitnextaction = 1,
    /// The OTA Provider is conveying a desire to rescind a previously provided Software Image.
    Discontinue = 2,
}

impl ApplyUpdateAction {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(ApplyUpdateAction::Proceed),
            1 => Some(ApplyUpdateAction::Awaitnextaction),
            2 => Some(ApplyUpdateAction::Discontinue),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<ApplyUpdateAction> for u8 {
    fn from(val: ApplyUpdateAction) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum DownloadProtocol {
    /// Indicates support for synchronous BDX.
    Bdxsynchronous = 0,
    /// Indicates support for asynchronous BDX.
    Bdxasynchronous = 1,
    /// Indicates support for HTTPS.
    Https = 2,
    /// Indicates support for vendor specific protocol.
    Vendorspecific = 3,
}

impl DownloadProtocol {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(DownloadProtocol::Bdxsynchronous),
            1 => Some(DownloadProtocol::Bdxasynchronous),
            2 => Some(DownloadProtocol::Https),
            3 => Some(DownloadProtocol::Vendorspecific),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<DownloadProtocol> for u8 {
    fn from(val: DownloadProtocol) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum Status {
    /// Indicates that the OTA Provider has an update available.
    Updateavailable = 0,
    /// Indicates OTA Provider may have an update, but it is not ready yet.
    Busy = 1,
    /// Indicates that there is definitely no update currently available from the OTA Provider.
    Notavailable = 2,
    /// Indicates that the requested download protocol is not supported by the OTA Provider.
    Downloadprotocolnotsupported = 3,
}

impl Status {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(Status::Updateavailable),
            1 => Some(Status::Busy),
            2 => Some(Status::Notavailable),
            3 => Some(Status::Downloadprotocolnotsupported),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<Status> for u8 {
    fn from(val: Status) -> Self {
        val as u8
    }
}

// Command encoders

/// Encode QueryImage command (0x00)
pub fn encode_query_image(vendor_id: u16, product_id: u16, software_version: u32, protocols_supported: Vec<DownloadProtocol>, hardware_version: u16, location: String, requestor_can_consent: bool, metadata_for_provider: Vec<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt16(vendor_id)).into(),
        (1, tlv::TlvItemValueEnc::UInt16(product_id)).into(),
        (2, tlv::TlvItemValueEnc::UInt32(software_version)).into(),
        (3, tlv::TlvItemValueEnc::StructAnon(protocols_supported.into_iter().map(|v| (0, tlv::TlvItemValueEnc::UInt8(v.to_u8())).into()).collect())).into(),
        (4, tlv::TlvItemValueEnc::UInt16(hardware_version)).into(),
        (5, tlv::TlvItemValueEnc::String(location)).into(),
        (6, tlv::TlvItemValueEnc::Bool(requestor_can_consent)).into(),
        (7, tlv::TlvItemValueEnc::OctetString(metadata_for_provider)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode ApplyUpdateRequest command (0x02)
pub fn encode_apply_update_request(update_token: Vec<u8>, new_version: u32) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::OctetString(update_token)).into(),
        (1, tlv::TlvItemValueEnc::UInt32(new_version)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode NotifyUpdateApplied command (0x04)
pub fn encode_notify_update_applied(update_token: Vec<u8>, software_version: u32) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::OctetString(update_token)).into(),
        (1, tlv::TlvItemValueEnc::UInt32(software_version)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

