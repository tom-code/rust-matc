//! Generated Matter TLV encoders and decoders for Service Area Cluster
//! Cluster ID: 0x0150
//!
//! This file is automatically generated from ServiceArea.xml

use crate::tlv;
use anyhow;
use serde_json;


// Enum definitions

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum OperationalStatus {
    /// The device has not yet started operating at the given area, or has not finished operating at that area but it is not currently operating at the area
    Pending = 0,
    /// The device is currently operating at the given area
    Operating = 1,
    /// The device has skipped the given area, before or during operating at it, due to a SkipArea command, due an out of band command (e.g. from the vendor's application), due to a vendor specific reason, such as a time limit used by the device, or due the device ending operating unsuccessfully
    Skipped = 2,
    /// The device has completed operating at the given area
    Completed = 3,
}

impl OperationalStatus {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(OperationalStatus::Pending),
            1 => Some(OperationalStatus::Operating),
            2 => Some(OperationalStatus::Skipped),
            3 => Some(OperationalStatus::Completed),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<OperationalStatus> for u8 {
    fn from(val: OperationalStatus) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum SelectAreasStatus {
    /// Attempting to operate in the areas identified by the entries of the NewAreas field is allowed and possible. The SelectedAreas attribute is set to the value of the NewAreas field.
    Success = 0,
    /// The value of at least one of the entries of the NewAreas field doesn't match any entries in the SupportedAreas attribute.
    Unsupportedarea = 1,
    /// The received request cannot be handled due to the current mode of the device.
    Invalidinmode = 2,
    /// The set of values is invalid. For example, areas on different floors, that a robot knows it can't reach on its own.
    Invalidset = 3,
}

impl SelectAreasStatus {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(SelectAreasStatus::Success),
            1 => Some(SelectAreasStatus::Unsupportedarea),
            2 => Some(SelectAreasStatus::Invalidinmode),
            3 => Some(SelectAreasStatus::Invalidset),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<SelectAreasStatus> for u8 {
    fn from(val: SelectAreasStatus) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum SkipAreaStatus {
    /// Skipping the area is allowed and possible, or the device was operating at the last available area and has stopped.
    Success = 0,
    /// The SelectedAreas attribute is empty.
    Invalidarealist = 1,
    /// The received request cannot be handled due to the current mode of the device. For example, the CurrentArea attribute is null or the device is not operating.
    Invalidinmode = 2,
    /// The SkippedArea field doesn't match an entry in the SupportedAreas list.
    Invalidskippedarea = 3,
}

impl SkipAreaStatus {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(SkipAreaStatus::Success),
            1 => Some(SkipAreaStatus::Invalidarealist),
            2 => Some(SkipAreaStatus::Invalidinmode),
            3 => Some(SkipAreaStatus::Invalidskippedarea),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<SkipAreaStatus> for u8 {
    fn from(val: SkipAreaStatus) -> Self {
        val as u8
    }
}

// Struct definitions

#[derive(Debug, serde::Serialize)]
pub struct AreaInfo {
    pub location_info: Option<LocationDescriptor>,
    pub landmark_info: Option<LandmarkInfo>,
}

#[derive(Debug, serde::Serialize)]
pub struct Area {
    pub area_id: Option<u32>,
    pub map_id: Option<u32>,
    pub area_info: Option<AreaInfo>,
}

#[derive(Debug, serde::Serialize)]
pub struct LandmarkInfo {
    pub landmark_tag: Option<u8>,
    pub relative_position_tag: Option<u8>,
}

#[derive(Debug, serde::Serialize)]
pub struct Map {
    pub map_id: Option<u32>,
    pub name: Option<String>,
}

#[derive(Debug, serde::Serialize)]
pub struct Progress {
    pub area_id: Option<u32>,
    pub status: Option<OperationalStatus>,
    pub total_operational_time: Option<u32>,
    pub estimated_time: Option<u32>,
}

#[derive(Debug, serde::Serialize)]
pub struct LocationDescriptor {
    pub location_name: Option<String>,
    pub floor_number: Option<u16>,
    pub area_type: Option<u8>,
}

// Command encoders

/// Encode SelectAreas command (0x00)
pub fn encode_select_areas(new_areas: Vec<u32>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::StructAnon(new_areas.into_iter().map(|v| (0, tlv::TlvItemValueEnc::UInt32(v as u32)).into()).collect())).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SkipArea command (0x02)
pub fn encode_skip_area(skipped_area: u32) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt32(skipped_area)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

// Attribute decoders

/// Decode SupportedAreas attribute (0x0000)
pub fn decode_supported_areas(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<Area>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(Area {
                area_id: item.get_int(&[0]).map(|v| v as u32),
                map_id: item.get_int(&[1]).map(|v| v as u32),
                area_info: {
                    if let Some(nested_tlv) = item.get(&[2]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 2, value: nested_tlv.clone() };
                            Some(AreaInfo {
                location_info: {
                    if let Some(nested_tlv) = nested_item.get(&[0]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 0, value: nested_tlv.clone() };
                            Some(LocationDescriptor {
                location_name: nested_item.get_string_owned(&[0]),
                floor_number: nested_item.get_int(&[1]).map(|v| v as u16),
                area_type: nested_item.get_int(&[2]).map(|v| v as u8),
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
                landmark_info: {
                    if let Some(nested_tlv) = nested_item.get(&[1]) {
                        if let tlv::TlvItemValue::List(_) = nested_tlv {
                            let nested_item = tlv::TlvItem { tag: 1, value: nested_tlv.clone() };
                            Some(LandmarkInfo {
                landmark_tag: nested_item.get_int(&[0]).map(|v| v as u8),
                relative_position_tag: nested_item.get_int(&[1]).map(|v| v as u8),
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
                            })
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                },
            });
        }
    }
    Ok(res)
}

/// Decode SupportedMaps attribute (0x0001)
pub fn decode_supported_maps(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<Map>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(Map {
                map_id: item.get_int(&[0]).map(|v| v as u32),
                name: item.get_string_owned(&[1]),
            });
        }
    }
    Ok(res)
}

/// Decode SelectedAreas attribute (0x0002)
pub fn decode_selected_areas(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<u32>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            if let tlv::TlvItemValue::Int(i) = &item.value {
                res.push(*i as u32);
            }
        }
    }
    Ok(res)
}

/// Decode CurrentArea attribute (0x0003)
pub fn decode_current_area(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u32>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u32))
    } else {
        Ok(None)
    }
}

/// Decode EstimatedEndTime attribute (0x0004)
pub fn decode_estimated_end_time(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u64>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v))
    } else {
        Ok(None)
    }
}

/// Decode Progress attribute (0x0005)
pub fn decode_progress(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<Progress>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(Progress {
                area_id: item.get_int(&[0]).map(|v| v as u32),
                status: item.get_int(&[1]).and_then(|v| OperationalStatus::from_u8(v as u8)),
                total_operational_time: item.get_int(&[2]).map(|v| v as u32),
                estimated_time: item.get_int(&[3]).map(|v| v as u32),
            });
        }
    }
    Ok(res)
}


// JSON dispatcher function

/// Decode attribute value and return as JSON string
/// 
/// # Parameters
/// * `cluster_id` - The cluster identifier
/// * `attribute_id` - The attribute identifier
/// * `tlv_value` - The TLV value to decode
/// 
/// # Returns
/// JSON string representation of the decoded value or error
pub fn decode_attribute_json(cluster_id: u32, attribute_id: u32, tlv_value: &crate::tlv::TlvItemValue) -> String {
    // Verify this is the correct cluster
    if cluster_id != 0x0150 {
        return format!("{{\"error\": \"Invalid cluster ID. Expected 0x0150, got {}\"}}", cluster_id);
    }
    
    match attribute_id {
        0x0000 => {
            match decode_supported_areas(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0001 => {
            match decode_supported_maps(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0002 => {
            match decode_selected_areas(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0003 => {
            match decode_current_area(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0004 => {
            match decode_estimated_end_time(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0005 => {
            match decode_progress(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        _ => format!("{{\"error\": \"Unknown attribute ID: {}\"}}", attribute_id),
    }
}

/// Get list of all attributes supported by this cluster
/// 
/// # Returns
/// Vector of tuples containing (attribute_id, attribute_name)
pub fn get_attribute_list() -> Vec<(u32, &'static str)> {
    vec![
        (0x0000, "SupportedAreas"),
        (0x0001, "SupportedMaps"),
        (0x0002, "SelectedAreas"),
        (0x0003, "CurrentArea"),
        (0x0004, "EstimatedEndTime"),
        (0x0005, "Progress"),
    ]
}

