//! Generated Matter TLV encoders and decoders for Thermostat Cluster
//! Cluster ID: 0x0201
//! 
//! This file is automatically generated from Thermostat.xml

use crate::tlv;
use anyhow;
use serde_json;


// Struct definitions

#[derive(Debug, serde::Serialize)]
pub struct Preset {
    pub preset_handle: Option<Vec<u8>>,
    pub preset_scenario: Option<u8>,
    pub name: Option<String>,
    pub cooling_setpoint: Option<u8>,
    pub heating_setpoint: Option<u8>,
    pub built_in: Option<bool>,
}

#[derive(Debug, serde::Serialize)]
pub struct PresetType {
    pub preset_scenario: Option<u8>,
    pub number_of_presets: Option<u8>,
    pub preset_type_features: Option<u8>,
}

#[derive(Debug, serde::Serialize)]
pub struct Schedule {
    pub schedule_handle: Option<Vec<u8>>,
    pub system_mode: Option<u8>,
    pub name: Option<String>,
    pub preset_handle: Option<Vec<u8>>,
    pub transitions: Option<Vec<ScheduleTransition>>,
    pub built_in: Option<bool>,
}

#[derive(Debug, serde::Serialize)]
pub struct ScheduleTransition {
    pub day_of_week: Option<u8>,
    pub transition_time: Option<u16>,
    pub preset_handle: Option<Vec<u8>>,
    pub system_mode: Option<u8>,
    pub cooling_setpoint: Option<u8>,
    pub heating_setpoint: Option<u8>,
}

#[derive(Debug, serde::Serialize)]
pub struct ScheduleType {
    pub system_mode: Option<u8>,
    pub number_of_schedules: Option<u8>,
    pub schedule_type_features: Option<u8>,
}

#[derive(Debug, serde::Serialize)]
pub struct WeeklyScheduleTransition {
    pub transition_time: Option<u16>,
    pub heat_setpoint: Option<u8>,
    pub cool_setpoint: Option<u8>,
}

// Command encoders

/// Encode SetpointRaiseLower command (0x00)
pub fn encode_setpoint_raise_lower(mode: u8, amount: i8) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(mode)).into(),
        (1, tlv::TlvItemValueEnc::Int8(amount)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetWeeklySchedule command (0x01)
pub fn encode_set_weekly_schedule(number_of_transitions_for_sequence: u8, day_of_week_for_sequence: u8, mode_for_sequence: u8, transitions: Vec<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(number_of_transitions_for_sequence)).into(),
        (1, tlv::TlvItemValueEnc::UInt8(day_of_week_for_sequence)).into(),
        (2, tlv::TlvItemValueEnc::UInt8(mode_for_sequence)).into(),
        (3, tlv::TlvItemValueEnc::StructAnon(transitions.into_iter().map(|v| (0, tlv::TlvItemValueEnc::UInt8(v)).into()).collect())).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode GetWeeklySchedule command (0x02)
pub fn encode_get_weekly_schedule(days_to_return: u8, mode_to_return: u8) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(days_to_return)).into(),
        (1, tlv::TlvItemValueEnc::UInt8(mode_to_return)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetActiveScheduleRequest command (0x05)
pub fn encode_set_active_schedule_request(schedule_handle: Vec<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::OctetString(schedule_handle)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetActivePresetRequest command (0x06)
pub fn encode_set_active_preset_request(preset_handle: Option<Vec<u8>>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::OctetString(preset_handle.unwrap_or(vec![]))).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

// Attribute decoders

/// Decode LocalTemperature attribute (0x0000)
pub fn decode_local_temperature(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode OutdoorTemperature attribute (0x0001)
pub fn decode_outdoor_temperature(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode Occupancy attribute (0x0002)
pub fn decode_occupancy(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode AbsMinHeatSetpointLimit attribute (0x0003)
pub fn decode_abs_min_heat_setpoint_limit(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode AbsMaxHeatSetpointLimit attribute (0x0004)
pub fn decode_abs_max_heat_setpoint_limit(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode AbsMinCoolSetpointLimit attribute (0x0005)
pub fn decode_abs_min_cool_setpoint_limit(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode AbsMaxCoolSetpointLimit attribute (0x0006)
pub fn decode_abs_max_cool_setpoint_limit(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode PICoolingDemand attribute (0x0007)
pub fn decode_pi_cooling_demand(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode PIHeatingDemand attribute (0x0008)
pub fn decode_pi_heating_demand(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode HVACSystemTypeConfiguration attribute (0x0009)
pub fn decode_hvac_system_type_configuration(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode LocalTemperatureCalibration attribute (0x0010)
pub fn decode_local_temperature_calibration(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode OccupiedCoolingSetpoint attribute (0x0011)
pub fn decode_occupied_cooling_setpoint(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode OccupiedHeatingSetpoint attribute (0x0012)
pub fn decode_occupied_heating_setpoint(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode UnoccupiedCoolingSetpoint attribute (0x0013)
pub fn decode_unoccupied_cooling_setpoint(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode UnoccupiedHeatingSetpoint attribute (0x0014)
pub fn decode_unoccupied_heating_setpoint(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode MinHeatSetpointLimit attribute (0x0015)
pub fn decode_min_heat_setpoint_limit(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode MaxHeatSetpointLimit attribute (0x0016)
pub fn decode_max_heat_setpoint_limit(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode MinCoolSetpointLimit attribute (0x0017)
pub fn decode_min_cool_setpoint_limit(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode MaxCoolSetpointLimit attribute (0x0018)
pub fn decode_max_cool_setpoint_limit(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode MinSetpointDeadBand attribute (0x0019)
pub fn decode_min_setpoint_dead_band(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode RemoteSensing attribute (0x001A)
pub fn decode_remote_sensing(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode ControlSequenceOfOperation attribute (0x001B)
pub fn decode_control_sequence_of_operation(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode SystemMode attribute (0x001C)
pub fn decode_system_mode(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode ThermostatRunningMode attribute (0x001E)
pub fn decode_thermostat_running_mode(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode StartOfWeek attribute (0x0020)
pub fn decode_start_of_week(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode NumberOfWeeklyTransitions attribute (0x0021)
pub fn decode_number_of_weekly_transitions(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode NumberOfDailyTransitions attribute (0x0022)
pub fn decode_number_of_daily_transitions(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode TemperatureSetpointHold attribute (0x0023)
pub fn decode_temperature_setpoint_hold(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode TemperatureSetpointHoldDuration attribute (0x0024)
pub fn decode_temperature_setpoint_hold_duration(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u16>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u16))
    } else {
        Ok(None)
    }
}

/// Decode ThermostatProgrammingOperationMode attribute (0x0025)
pub fn decode_thermostat_programming_operation_mode(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode ThermostatRunningState attribute (0x0029)
pub fn decode_thermostat_running_state(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode SetpointChangeSource attribute (0x0030)
pub fn decode_setpoint_change_source(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode SetpointChangeAmount attribute (0x0031)
pub fn decode_setpoint_change_amount(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode SetpointChangeSourceTimestamp attribute (0x0032)
pub fn decode_setpoint_change_source_timestamp(inp: &tlv::TlvItemValue) -> anyhow::Result<u64> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode OccupiedSetback attribute (0x0034)
pub fn decode_occupied_setback(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode OccupiedSetbackMin attribute (0x0035)
pub fn decode_occupied_setback_min(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode OccupiedSetbackMax attribute (0x0036)
pub fn decode_occupied_setback_max(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode UnoccupiedSetback attribute (0x0037)
pub fn decode_unoccupied_setback(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode UnoccupiedSetbackMin attribute (0x0038)
pub fn decode_unoccupied_setback_min(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode UnoccupiedSetbackMax attribute (0x0039)
pub fn decode_unoccupied_setback_max(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode EmergencyHeatDelta attribute (0x003A)
pub fn decode_emergency_heat_delta(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode ACType attribute (0x0040)
pub fn decode_ac_type(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode ACCapacity attribute (0x0041)
pub fn decode_ac_capacity(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode ACRefrigerantType attribute (0x0042)
pub fn decode_ac_refrigerant_type(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode ACCompressorType attribute (0x0043)
pub fn decode_ac_compressor_type(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode ACErrorCode attribute (0x0044)
pub fn decode_ac_error_code(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode ACLouverPosition attribute (0x0045)
pub fn decode_aclouver_position(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode ACCoilTemperature attribute (0x0046)
pub fn decode_ac_coil_temperature(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode ACCapacityFormat attribute (0x0047)
pub fn decode_ac_capacity_format(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode PresetTypes attribute (0x0048)
pub fn decode_preset_types(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<PresetType>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(PresetType {
                preset_scenario: item.get_int(&[0]).map(|v| v as u8),
                number_of_presets: item.get_int(&[1]).map(|v| v as u8),
                preset_type_features: item.get_int(&[2]).map(|v| v as u8),
            });
        }
    }
    Ok(res)
}

/// Decode ScheduleTypes attribute (0x0049)
pub fn decode_schedule_types(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<ScheduleType>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(ScheduleType {
                system_mode: item.get_int(&[0]).map(|v| v as u8),
                number_of_schedules: item.get_int(&[1]).map(|v| v as u8),
                schedule_type_features: item.get_int(&[2]).map(|v| v as u8),
            });
        }
    }
    Ok(res)
}

/// Decode NumberOfPresets attribute (0x004A)
pub fn decode_number_of_presets(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode NumberOfSchedules attribute (0x004B)
pub fn decode_number_of_schedules(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode NumberOfScheduleTransitions attribute (0x004C)
pub fn decode_number_of_schedule_transitions(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode NumberOfScheduleTransitionPerDay attribute (0x004D)
pub fn decode_number_of_schedule_transition_per_day(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode ActivePresetHandle attribute (0x004E)
pub fn decode_active_preset_handle(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<Vec<u8>>> {
    if let tlv::TlvItemValue::OctetString(v) = inp {
        Ok(Some(v.clone()))
    } else {
        Ok(None)
    }
}

/// Decode ActiveScheduleHandle attribute (0x004F)
pub fn decode_active_schedule_handle(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<Vec<u8>>> {
    if let tlv::TlvItemValue::OctetString(v) = inp {
        Ok(Some(v.clone()))
    } else {
        Ok(None)
    }
}

/// Decode Presets attribute (0x0050)
pub fn decode_presets(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<Preset>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(Preset {
                preset_handle: item.get_octet_string_owned(&[0]),
                preset_scenario: item.get_int(&[1]).map(|v| v as u8),
                name: item.get_string_owned(&[2]),
                cooling_setpoint: item.get_int(&[3]).map(|v| v as u8),
                heating_setpoint: item.get_int(&[4]).map(|v| v as u8),
                built_in: item.get_bool(&[5]),
            });
        }
    }
    Ok(res)
}

/// Decode Schedules attribute (0x0051)
pub fn decode_schedules(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<Schedule>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(Schedule {
                schedule_handle: item.get_octet_string_owned(&[0]),
                system_mode: item.get_int(&[1]).map(|v| v as u8),
                name: item.get_string_owned(&[2]),
                preset_handle: item.get_octet_string_owned(&[3]),
                transitions: {
                    if let Some(tlv::TlvItemValue::List(l)) = item.get(&[4]) {
                        let mut items = Vec::new();
                        for list_item in l {
                            items.push(ScheduleTransition {
                day_of_week: list_item.get_int(&[0]).map(|v| v as u8),
                transition_time: list_item.get_int(&[1]).map(|v| v as u16),
                preset_handle: list_item.get_octet_string_owned(&[2]),
                system_mode: list_item.get_int(&[3]).map(|v| v as u8),
                cooling_setpoint: list_item.get_int(&[4]).map(|v| v as u8),
                heating_setpoint: list_item.get_int(&[5]).map(|v| v as u8),
                            });
                        }
                        Some(items)
                    } else {
                        None
                    }
                },
                built_in: item.get_bool(&[5]),
            });
        }
    }
    Ok(res)
}

/// Decode SetpointHoldExpiryTimestamp attribute (0x0052)
pub fn decode_setpoint_hold_expiry_timestamp(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u64>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v))
    } else {
        Ok(None)
    }
}


// JSON dispatcher function

/// Decode attribute value and return as JSON string
/// 
/// # Parameters
/// * `cluster_id` - The cluster identifier
/// * `attribute_id` - The attribute identifier
/// * `tlv_value` - The TLV value to decode
/// 
/// # Returns
/// JSON string representation of the decoded value or error
pub fn decode_attribute_json(cluster_id: u32, attribute_id: u32, tlv_value: &crate::tlv::TlvItemValue) -> String {
    // Verify this is the correct cluster
    if cluster_id != 0x0201 {
        return format!("{{\"error\": \"Invalid cluster ID. Expected 0x0201, got {}\"}}", cluster_id);
    }
    
    match attribute_id {
        0x0000 => {
            match decode_local_temperature(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0001 => {
            match decode_outdoor_temperature(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0002 => {
            match decode_occupancy(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0003 => {
            match decode_abs_min_heat_setpoint_limit(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0004 => {
            match decode_abs_max_heat_setpoint_limit(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0005 => {
            match decode_abs_min_cool_setpoint_limit(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0006 => {
            match decode_abs_max_cool_setpoint_limit(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0007 => {
            match decode_pi_cooling_demand(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0008 => {
            match decode_pi_heating_demand(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0009 => {
            match decode_hvac_system_type_configuration(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0010 => {
            match decode_local_temperature_calibration(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0011 => {
            match decode_occupied_cooling_setpoint(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0012 => {
            match decode_occupied_heating_setpoint(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0013 => {
            match decode_unoccupied_cooling_setpoint(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0014 => {
            match decode_unoccupied_heating_setpoint(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0015 => {
            match decode_min_heat_setpoint_limit(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0016 => {
            match decode_max_heat_setpoint_limit(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0017 => {
            match decode_min_cool_setpoint_limit(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0018 => {
            match decode_max_cool_setpoint_limit(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0019 => {
            match decode_min_setpoint_dead_band(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x001A => {
            match decode_remote_sensing(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x001B => {
            match decode_control_sequence_of_operation(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x001C => {
            match decode_system_mode(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x001E => {
            match decode_thermostat_running_mode(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0020 => {
            match decode_start_of_week(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0021 => {
            match decode_number_of_weekly_transitions(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0022 => {
            match decode_number_of_daily_transitions(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0023 => {
            match decode_temperature_setpoint_hold(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0024 => {
            match decode_temperature_setpoint_hold_duration(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0025 => {
            match decode_thermostat_programming_operation_mode(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0029 => {
            match decode_thermostat_running_state(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0030 => {
            match decode_setpoint_change_source(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0031 => {
            match decode_setpoint_change_amount(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0032 => {
            match decode_setpoint_change_source_timestamp(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0034 => {
            match decode_occupied_setback(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0035 => {
            match decode_occupied_setback_min(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0036 => {
            match decode_occupied_setback_max(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0037 => {
            match decode_unoccupied_setback(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0038 => {
            match decode_unoccupied_setback_min(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0039 => {
            match decode_unoccupied_setback_max(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x003A => {
            match decode_emergency_heat_delta(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0040 => {
            match decode_ac_type(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0041 => {
            match decode_ac_capacity(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0042 => {
            match decode_ac_refrigerant_type(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0043 => {
            match decode_ac_compressor_type(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0044 => {
            match decode_ac_error_code(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0045 => {
            match decode_aclouver_position(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0046 => {
            match decode_ac_coil_temperature(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0047 => {
            match decode_ac_capacity_format(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0048 => {
            match decode_preset_types(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0049 => {
            match decode_schedule_types(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x004A => {
            match decode_number_of_presets(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x004B => {
            match decode_number_of_schedules(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x004C => {
            match decode_number_of_schedule_transitions(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x004D => {
            match decode_number_of_schedule_transition_per_day(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x004E => {
            match decode_active_preset_handle(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x004F => {
            match decode_active_schedule_handle(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0050 => {
            match decode_presets(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0051 => {
            match decode_schedules(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0052 => {
            match decode_setpoint_hold_expiry_timestamp(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        _ => format!("{{\"error\": \"Unknown attribute ID: {}\"}}", attribute_id),
    }
}

/// Get list of all attributes supported by this cluster
/// 
/// # Returns
/// Vector of tuples containing (attribute_id, attribute_name)
pub fn get_attribute_list() -> Vec<(u32, &'static str)> {
    vec![
        (0x0000, "LocalTemperature"),
        (0x0001, "OutdoorTemperature"),
        (0x0002, "Occupancy"),
        (0x0003, "AbsMinHeatSetpointLimit"),
        (0x0004, "AbsMaxHeatSetpointLimit"),
        (0x0005, "AbsMinCoolSetpointLimit"),
        (0x0006, "AbsMaxCoolSetpointLimit"),
        (0x0007, "PICoolingDemand"),
        (0x0008, "PIHeatingDemand"),
        (0x0009, "HVACSystemTypeConfiguration"),
        (0x0010, "LocalTemperatureCalibration"),
        (0x0011, "OccupiedCoolingSetpoint"),
        (0x0012, "OccupiedHeatingSetpoint"),
        (0x0013, "UnoccupiedCoolingSetpoint"),
        (0x0014, "UnoccupiedHeatingSetpoint"),
        (0x0015, "MinHeatSetpointLimit"),
        (0x0016, "MaxHeatSetpointLimit"),
        (0x0017, "MinCoolSetpointLimit"),
        (0x0018, "MaxCoolSetpointLimit"),
        (0x0019, "MinSetpointDeadBand"),
        (0x001A, "RemoteSensing"),
        (0x001B, "ControlSequenceOfOperation"),
        (0x001C, "SystemMode"),
        (0x001E, "ThermostatRunningMode"),
        (0x0020, "StartOfWeek"),
        (0x0021, "NumberOfWeeklyTransitions"),
        (0x0022, "NumberOfDailyTransitions"),
        (0x0023, "TemperatureSetpointHold"),
        (0x0024, "TemperatureSetpointHoldDuration"),
        (0x0025, "ThermostatProgrammingOperationMode"),
        (0x0029, "ThermostatRunningState"),
        (0x0030, "SetpointChangeSource"),
        (0x0031, "SetpointChangeAmount"),
        (0x0032, "SetpointChangeSourceTimestamp"),
        (0x0034, "OccupiedSetback"),
        (0x0035, "OccupiedSetbackMin"),
        (0x0036, "OccupiedSetbackMax"),
        (0x0037, "UnoccupiedSetback"),
        (0x0038, "UnoccupiedSetbackMin"),
        (0x0039, "UnoccupiedSetbackMax"),
        (0x003A, "EmergencyHeatDelta"),
        (0x0040, "ACType"),
        (0x0041, "ACCapacity"),
        (0x0042, "ACRefrigerantType"),
        (0x0043, "ACCompressorType"),
        (0x0044, "ACErrorCode"),
        (0x0045, "ACLouverPosition"),
        (0x0046, "ACCoilTemperature"),
        (0x0047, "ACCapacityFormat"),
        (0x0048, "PresetTypes"),
        (0x0049, "ScheduleTypes"),
        (0x004A, "NumberOfPresets"),
        (0x004B, "NumberOfSchedules"),
        (0x004C, "NumberOfScheduleTransitions"),
        (0x004D, "NumberOfScheduleTransitionPerDay"),
        (0x004E, "ActivePresetHandle"),
        (0x004F, "ActiveScheduleHandle"),
        (0x0050, "Presets"),
        (0x0051, "Schedules"),
        (0x0052, "SetpointHoldExpiryTimestamp"),
    ]
}

