//! Generated Matter TLV encoders and decoders for Pump Configuration and Control Cluster
//! Cluster ID: 0x0200
//!
//! This file is automatically generated from PumpConfigurationControl.xml

use crate::tlv;
use anyhow;
use serde_json;


// Enum definitions

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ControlMode {
    /// The pump is running at a constant speed.
    Constantspeed = 0,
    /// The pump will regulate its speed to maintain a constant differential pressure over its flanges.
    Constantpressure = 1,
    /// The pump will regulate its speed to maintain a constant differential pressure over its flanges.
    Proportionalpressure = 2,
    /// The pump will regulate its speed to maintain a constant flow through the pump.
    Constantflow = 3,
    /// The pump will regulate its speed to maintain a constant temperature.
    Constanttemperature = 5,
    /// The operation of the pump is automatically optimized to provide the most suitable performance with respect to comfort and energy savings.
    Automatic = 7,
}

impl ControlMode {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(ControlMode::Constantspeed),
            1 => Some(ControlMode::Constantpressure),
            2 => Some(ControlMode::Proportionalpressure),
            3 => Some(ControlMode::Constantflow),
            5 => Some(ControlMode::Constanttemperature),
            7 => Some(ControlMode::Automatic),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<ControlMode> for u8 {
    fn from(val: ControlMode) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum OperationMode {
    /// The pump is controlled by a setpoint, as defined by a connected remote sensor or by the ControlMode attribute.
    Normal = 0,
    /// This value sets the pump to run at the minimum possible speed it can without being stopped.
    Minimum = 1,
    /// This value sets the pump to run at its maximum possible speed.
    Maximum = 2,
    /// This value sets the pump to run with the local settings of the pump, regardless of what these are.
    Local = 3,
}

impl OperationMode {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(OperationMode::Normal),
            1 => Some(OperationMode::Minimum),
            2 => Some(OperationMode::Maximum),
            3 => Some(OperationMode::Local),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<OperationMode> for u8 {
    fn from(val: OperationMode) -> Self {
        val as u8
    }
}

// Bitmap definitions

/// PumpStatus bitmap type
pub type PumpStatus = u16;

/// Constants for PumpStatus
pub mod pumpstatus {
    /// A fault related to the system or pump device is detected.
    pub const DEVICE_FAULT: u16 = 0x01;
    /// A fault related to the supply to the pump is detected.
    pub const SUPPLY_FAULT: u16 = 0x02;
    /// Setpoint is too low to achieve.
    pub const SPEED_LOW: u16 = 0x04;
    /// Setpoint is too high to achieve.
    pub const SPEED_HIGH: u16 = 0x08;
    /// Device control is overridden by hardware, such as an external STOP button or via a local HMI.
    pub const LOCAL_OVERRIDE: u16 = 0x10;
    /// Pump is currently running
    pub const RUNNING: u16 = 0x20;
    /// A remote pressure sensor is used as the sensor for the regulation of the pump.
    pub const REMOTE_PRESSURE: u16 = 0x40;
    /// A remote flow sensor is used as the sensor for the regulation of the pump.
    pub const REMOTE_FLOW: u16 = 0x80;
    /// A remote temperature sensor is used as the sensor for the regulation of the pump.
    pub const REMOTE_TEMPERATURE: u16 = 0x100;
}

// Attribute decoders

/// Decode MaxPressure attribute (0x0000)
pub fn decode_max_pressure(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<i16>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as i16))
    } else {
        Ok(None)
    }
}

/// Decode MaxSpeed attribute (0x0001)
pub fn decode_max_speed(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u16>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u16))
    } else {
        Ok(None)
    }
}

/// Decode MaxFlow attribute (0x0002)
pub fn decode_max_flow(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u16>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u16))
    } else {
        Ok(None)
    }
}

/// Decode MinConstPressure attribute (0x0003)
pub fn decode_min_const_pressure(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<i16>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as i16))
    } else {
        Ok(None)
    }
}

/// Decode MaxConstPressure attribute (0x0004)
pub fn decode_max_const_pressure(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<i16>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as i16))
    } else {
        Ok(None)
    }
}

/// Decode MinCompPressure attribute (0x0005)
pub fn decode_min_comp_pressure(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<i16>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as i16))
    } else {
        Ok(None)
    }
}

/// Decode MaxCompPressure attribute (0x0006)
pub fn decode_max_comp_pressure(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<i16>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as i16))
    } else {
        Ok(None)
    }
}

/// Decode MinConstSpeed attribute (0x0007)
pub fn decode_min_const_speed(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u16>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u16))
    } else {
        Ok(None)
    }
}

/// Decode MaxConstSpeed attribute (0x0008)
pub fn decode_max_const_speed(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u16>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u16))
    } else {
        Ok(None)
    }
}

/// Decode MinConstFlow attribute (0x0009)
pub fn decode_min_const_flow(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u16>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u16))
    } else {
        Ok(None)
    }
}

/// Decode MaxConstFlow attribute (0x000A)
pub fn decode_max_const_flow(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u16>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u16))
    } else {
        Ok(None)
    }
}

/// Decode MinConstTemp attribute (0x000B)
pub fn decode_min_const_temp(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<i16>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as i16))
    } else {
        Ok(None)
    }
}

/// Decode MaxConstTemp attribute (0x000C)
pub fn decode_max_const_temp(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<i16>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as i16))
    } else {
        Ok(None)
    }
}

/// Decode PumpStatus attribute (0x0010)
pub fn decode_pump_status(inp: &tlv::TlvItemValue) -> anyhow::Result<PumpStatus> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode EffectiveOperationMode attribute (0x0011)
pub fn decode_effective_operation_mode(inp: &tlv::TlvItemValue) -> anyhow::Result<OperationMode> {
    if let tlv::TlvItemValue::Int(v) = inp {
        OperationMode::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode EffectiveControlMode attribute (0x0012)
pub fn decode_effective_control_mode(inp: &tlv::TlvItemValue) -> anyhow::Result<ControlMode> {
    if let tlv::TlvItemValue::Int(v) = inp {
        ControlMode::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode Capacity attribute (0x0013)
pub fn decode_capacity(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<i16>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as i16))
    } else {
        Ok(None)
    }
}

/// Decode Speed attribute (0x0014)
pub fn decode_speed(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u16>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u16))
    } else {
        Ok(None)
    }
}

/// Decode LifetimeRunningHours attribute (0x0015)
pub fn decode_lifetime_running_hours(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode Power attribute (0x0016)
pub fn decode_power(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode LifetimeEnergyConsumed attribute (0x0017)
pub fn decode_lifetime_energy_consumed(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u32>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u32))
    } else {
        Ok(None)
    }
}

/// Decode OperationMode attribute (0x0020)
pub fn decode_operation_mode(inp: &tlv::TlvItemValue) -> anyhow::Result<OperationMode> {
    if let tlv::TlvItemValue::Int(v) = inp {
        OperationMode::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode ControlMode attribute (0x0021)
pub fn decode_control_mode(inp: &tlv::TlvItemValue) -> anyhow::Result<ControlMode> {
    if let tlv::TlvItemValue::Int(v) = inp {
        ControlMode::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode AlarmMask attribute (0x0022)
pub fn decode_alarm_mask(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}


// JSON dispatcher function

/// Decode attribute value and return as JSON string
/// 
/// # Parameters
/// * `cluster_id` - The cluster identifier
/// * `attribute_id` - The attribute identifier
/// * `tlv_value` - The TLV value to decode
/// 
/// # Returns
/// JSON string representation of the decoded value or error
pub fn decode_attribute_json(cluster_id: u32, attribute_id: u32, tlv_value: &crate::tlv::TlvItemValue) -> String {
    // Verify this is the correct cluster
    if cluster_id != 0x0200 {
        return format!("{{\"error\": \"Invalid cluster ID. Expected 0x0200, got {}\"}}", cluster_id);
    }
    
    match attribute_id {
        0x0000 => {
            match decode_max_pressure(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0001 => {
            match decode_max_speed(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0002 => {
            match decode_max_flow(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0003 => {
            match decode_min_const_pressure(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0004 => {
            match decode_max_const_pressure(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0005 => {
            match decode_min_comp_pressure(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0006 => {
            match decode_max_comp_pressure(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0007 => {
            match decode_min_const_speed(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0008 => {
            match decode_max_const_speed(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0009 => {
            match decode_min_const_flow(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000A => {
            match decode_max_const_flow(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000B => {
            match decode_min_const_temp(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000C => {
            match decode_max_const_temp(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0010 => {
            match decode_pump_status(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0011 => {
            match decode_effective_operation_mode(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0012 => {
            match decode_effective_control_mode(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0013 => {
            match decode_capacity(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0014 => {
            match decode_speed(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0015 => {
            match decode_lifetime_running_hours(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0016 => {
            match decode_power(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0017 => {
            match decode_lifetime_energy_consumed(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0020 => {
            match decode_operation_mode(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0021 => {
            match decode_control_mode(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0022 => {
            match decode_alarm_mask(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        _ => format!("{{\"error\": \"Unknown attribute ID: {}\"}}", attribute_id),
    }
}

/// Get list of all attributes supported by this cluster
/// 
/// # Returns
/// Vector of tuples containing (attribute_id, attribute_name)
pub fn get_attribute_list() -> Vec<(u32, &'static str)> {
    vec![
        (0x0000, "MaxPressure"),
        (0x0001, "MaxSpeed"),
        (0x0002, "MaxFlow"),
        (0x0003, "MinConstPressure"),
        (0x0004, "MaxConstPressure"),
        (0x0005, "MinCompPressure"),
        (0x0006, "MaxCompPressure"),
        (0x0007, "MinConstSpeed"),
        (0x0008, "MaxConstSpeed"),
        (0x0009, "MinConstFlow"),
        (0x000A, "MaxConstFlow"),
        (0x000B, "MinConstTemp"),
        (0x000C, "MaxConstTemp"),
        (0x0010, "PumpStatus"),
        (0x0011, "EffectiveOperationMode"),
        (0x0012, "EffectiveControlMode"),
        (0x0013, "Capacity"),
        (0x0014, "Speed"),
        (0x0015, "LifetimeRunningHours"),
        (0x0016, "Power"),
        (0x0017, "LifetimeEnergyConsumed"),
        (0x0020, "OperationMode"),
        (0x0021, "ControlMode"),
        (0x0022, "AlarmMask"),
    ]
}

