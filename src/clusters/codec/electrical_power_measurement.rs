//! Generated Matter TLV encoders and decoders for Electrical Power Measurement Cluster
//! Cluster ID: 0x0090
//!
//! This file is automatically generated from ElectricalPowerMeasurement.xml

use crate::tlv;
use anyhow;
use serde_json;


// Enum definitions

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum MeasurementType {
    Unspecified = 0,
    /// Voltage in millivolts (mV)
    Voltage = 1,
    /// Active current in milliamps (mA)
    Activecurrent = 2,
    /// Reactive current in milliamps (mA)
    Reactivecurrent = 3,
    /// Apparent current in milliamps (mA)
    Apparentcurrent = 4,
    /// Active power in milliwatts (mW)
    Activepower = 5,
    /// Reactive power in millivolt-amps reactive (mVAR)
    Reactivepower = 6,
    /// Apparent power in millivolt-amps (mVA)
    Apparentpower = 7,
    /// Root mean squared voltage in millivolts (mV)
    Rmsvoltage = 8,
    /// Root mean squared current in milliamps (mA)
    Rmscurrent = 9,
    /// Root mean squared power in milliwatts (mW)
    Rmspower = 10,
    /// AC frequency in millihertz (mHz)
    Frequency = 11,
    /// Power Factor ratio in +/- 1/100ths of a percent.
    Powerfactor = 12,
    /// AC neutral current in milliamps (mA)
    Neutralcurrent = 13,
    /// Electrical energy in milliwatt-hours (mWh)
    Electricalenergy = 14,
    /// Reactive power in millivolt-amp-hours reactive (mVARh)
    Reactiveenergy = 15,
    /// Apparent power in millivolt-amp-hours (mVAh)
    Apparentenergy = 16,
}

impl MeasurementType {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(MeasurementType::Unspecified),
            1 => Some(MeasurementType::Voltage),
            2 => Some(MeasurementType::Activecurrent),
            3 => Some(MeasurementType::Reactivecurrent),
            4 => Some(MeasurementType::Apparentcurrent),
            5 => Some(MeasurementType::Activepower),
            6 => Some(MeasurementType::Reactivepower),
            7 => Some(MeasurementType::Apparentpower),
            8 => Some(MeasurementType::Rmsvoltage),
            9 => Some(MeasurementType::Rmscurrent),
            10 => Some(MeasurementType::Rmspower),
            11 => Some(MeasurementType::Frequency),
            12 => Some(MeasurementType::Powerfactor),
            13 => Some(MeasurementType::Neutralcurrent),
            14 => Some(MeasurementType::Electricalenergy),
            15 => Some(MeasurementType::Reactiveenergy),
            16 => Some(MeasurementType::Apparentenergy),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<MeasurementType> for u8 {
    fn from(val: MeasurementType) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum PowerMode {
    Unknown = 0,
    /// Direct current
    Dc = 1,
    /// Alternating current, either single-phase or polyphase
    Ac = 2,
}

impl PowerMode {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(PowerMode::Unknown),
            1 => Some(PowerMode::Dc),
            2 => Some(PowerMode::Ac),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<PowerMode> for u8 {
    fn from(val: PowerMode) -> Self {
        val as u8
    }
}

// Struct definitions

#[derive(Debug, serde::Serialize)]
pub struct HarmonicMeasurement {
    pub order: Option<u8>,
    pub measurement: Option<i64>,
}

#[derive(Debug, serde::Serialize)]
pub struct MeasurementAccuracyRange {
    pub range_min: Option<i64>,
    pub range_max: Option<i64>,
    pub percent_max: Option<u8>,
    pub percent_min: Option<u8>,
    pub percent_typical: Option<u8>,
    pub fixed_max: Option<u64>,
    pub fixed_min: Option<u64>,
    pub fixed_typical: Option<u64>,
}

#[derive(Debug, serde::Serialize)]
pub struct MeasurementAccuracy {
    pub measurement_type: Option<MeasurementType>,
    pub measured: Option<bool>,
    pub min_measured_value: Option<i64>,
    pub max_measured_value: Option<i64>,
    pub accuracy_ranges: Option<Vec<MeasurementAccuracyRange>>,
}

#[derive(Debug, serde::Serialize)]
pub struct MeasurementRange {
    pub measurement_type: Option<MeasurementType>,
    pub min: Option<i64>,
    pub max: Option<i64>,
    pub start_timestamp: Option<u64>,
    pub end_timestamp: Option<u64>,
    pub min_timestamp: Option<u64>,
    pub max_timestamp: Option<u64>,
    pub start_systime: Option<u8>,
    pub end_systime: Option<u8>,
    pub min_systime: Option<u8>,
    pub max_systime: Option<u8>,
}

// Attribute decoders

/// Decode PowerMode attribute (0x0000)
pub fn decode_power_mode(inp: &tlv::TlvItemValue) -> anyhow::Result<PowerMode> {
    if let tlv::TlvItemValue::Int(v) = inp {
        PowerMode::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode NumberOfMeasurementTypes attribute (0x0001)
pub fn decode_number_of_measurement_types(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode Accuracy attribute (0x0002)
pub fn decode_accuracy(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<MeasurementAccuracy>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(MeasurementAccuracy {
                measurement_type: item.get_int(&[0]).and_then(|v| MeasurementType::from_u8(v as u8)),
                measured: item.get_bool(&[1]),
                min_measured_value: item.get_int(&[2]).map(|v| v as i64),
                max_measured_value: item.get_int(&[3]).map(|v| v as i64),
                accuracy_ranges: {
                    if let Some(tlv::TlvItemValue::List(l)) = item.get(&[4]) {
                        let mut items = Vec::new();
                        for list_item in l {
                            items.push(MeasurementAccuracyRange {
                range_min: list_item.get_int(&[0]).map(|v| v as i64),
                range_max: list_item.get_int(&[1]).map(|v| v as i64),
                percent_max: list_item.get_int(&[2]).map(|v| v as u8),
                percent_min: list_item.get_int(&[3]).map(|v| v as u8),
                percent_typical: list_item.get_int(&[4]).map(|v| v as u8),
                fixed_max: list_item.get_int(&[5]),
                fixed_min: list_item.get_int(&[6]),
                fixed_typical: list_item.get_int(&[7]),
                            });
                        }
                        Some(items)
                    } else {
                        None
                    }
                },
            });
        }
    }
    Ok(res)
}

/// Decode Ranges attribute (0x0003)
pub fn decode_ranges(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<MeasurementRange>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(MeasurementRange {
                measurement_type: item.get_int(&[0]).and_then(|v| MeasurementType::from_u8(v as u8)),
                min: item.get_int(&[1]).map(|v| v as i64),
                max: item.get_int(&[2]).map(|v| v as i64),
                start_timestamp: item.get_int(&[3]),
                end_timestamp: item.get_int(&[4]),
                min_timestamp: item.get_int(&[5]),
                max_timestamp: item.get_int(&[6]),
                start_systime: item.get_int(&[7]).map(|v| v as u8),
                end_systime: item.get_int(&[8]).map(|v| v as u8),
                min_systime: item.get_int(&[9]).map(|v| v as u8),
                max_systime: item.get_int(&[10]).map(|v| v as u8),
            });
        }
    }
    Ok(res)
}

/// Decode Voltage attribute (0x0004)
pub fn decode_voltage(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode ActiveCurrent attribute (0x0005)
pub fn decode_active_current(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode ReactiveCurrent attribute (0x0006)
pub fn decode_reactive_current(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode ApparentCurrent attribute (0x0007)
pub fn decode_apparent_current(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode ActivePower attribute (0x0008)
pub fn decode_active_power(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u32>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u32))
    } else {
        Ok(None)
    }
}

/// Decode ReactivePower attribute (0x0009)
pub fn decode_reactive_power(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode ApparentPower attribute (0x000A)
pub fn decode_apparent_power(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode RMSVoltage attribute (0x000B)
pub fn decode_rms_voltage(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode RMSCurrent attribute (0x000C)
pub fn decode_rms_current(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode RMSPower attribute (0x000D)
pub fn decode_rms_power(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u32>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u32))
    } else {
        Ok(None)
    }
}

/// Decode Frequency attribute (0x000E)
pub fn decode_frequency(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<i64>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as i64))
    } else {
        Ok(None)
    }
}

/// Decode HarmonicCurrents attribute (0x000F)
pub fn decode_harmonic_currents(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<HarmonicMeasurement>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(HarmonicMeasurement {
                order: item.get_int(&[0]).map(|v| v as u8),
                measurement: item.get_int(&[1]).map(|v| v as i64),
            });
        }
    }
    Ok(res)
}

/// Decode HarmonicPhases attribute (0x0010)
pub fn decode_harmonic_phases(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<HarmonicMeasurement>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(HarmonicMeasurement {
                order: item.get_int(&[0]).map(|v| v as u8),
                measurement: item.get_int(&[1]).map(|v| v as i64),
            });
        }
    }
    Ok(res)
}

/// Decode PowerFactor attribute (0x0011)
pub fn decode_power_factor(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<i64>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as i64))
    } else {
        Ok(None)
    }
}

/// Decode NeutralCurrent attribute (0x0012)
pub fn decode_neutral_current(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}


// JSON dispatcher function

/// Decode attribute value and return as JSON string
/// 
/// # Parameters
/// * `cluster_id` - The cluster identifier
/// * `attribute_id` - The attribute identifier
/// * `tlv_value` - The TLV value to decode
/// 
/// # Returns
/// JSON string representation of the decoded value or error
pub fn decode_attribute_json(cluster_id: u32, attribute_id: u32, tlv_value: &crate::tlv::TlvItemValue) -> String {
    // Verify this is the correct cluster
    if cluster_id != 0x0090 {
        return format!("{{\"error\": \"Invalid cluster ID. Expected 0x0090, got {}\"}}", cluster_id);
    }
    
    match attribute_id {
        0x0000 => {
            match decode_power_mode(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0001 => {
            match decode_number_of_measurement_types(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0002 => {
            match decode_accuracy(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0003 => {
            match decode_ranges(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0004 => {
            match decode_voltage(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0005 => {
            match decode_active_current(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0006 => {
            match decode_reactive_current(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0007 => {
            match decode_apparent_current(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0008 => {
            match decode_active_power(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0009 => {
            match decode_reactive_power(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000A => {
            match decode_apparent_power(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000B => {
            match decode_rms_voltage(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000C => {
            match decode_rms_current(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000D => {
            match decode_rms_power(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000E => {
            match decode_frequency(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000F => {
            match decode_harmonic_currents(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0010 => {
            match decode_harmonic_phases(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0011 => {
            match decode_power_factor(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0012 => {
            match decode_neutral_current(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        _ => format!("{{\"error\": \"Unknown attribute ID: {}\"}}", attribute_id),
    }
}

/// Get list of all attributes supported by this cluster
/// 
/// # Returns
/// Vector of tuples containing (attribute_id, attribute_name)
pub fn get_attribute_list() -> Vec<(u32, &'static str)> {
    vec![
        (0x0000, "PowerMode"),
        (0x0001, "NumberOfMeasurementTypes"),
        (0x0002, "Accuracy"),
        (0x0003, "Ranges"),
        (0x0004, "Voltage"),
        (0x0005, "ActiveCurrent"),
        (0x0006, "ReactiveCurrent"),
        (0x0007, "ApparentCurrent"),
        (0x0008, "ActivePower"),
        (0x0009, "ReactivePower"),
        (0x000A, "ApparentPower"),
        (0x000B, "RMSVoltage"),
        (0x000C, "RMSCurrent"),
        (0x000D, "RMSPower"),
        (0x000E, "Frequency"),
        (0x000F, "HarmonicCurrents"),
        (0x0010, "HarmonicPhases"),
        (0x0011, "PowerFactor"),
        (0x0012, "NeutralCurrent"),
    ]
}

