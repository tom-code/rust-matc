//! Generated Matter TLV encoders and decoders for Energy EVSE Cluster
//! Cluster ID: 0x0099
//!
//! This file is automatically generated from EnergyEVSE.xml

use crate::tlv;
use anyhow;
use serde_json;


// Enum definitions

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum EnergyTransferStoppedReason {
    /// The EV decided to stop
    Evstopped = 0,
    /// The EVSE decided to stop
    Evsestopped = 1,
    /// An other unknown reason
    Other = 2,
}

impl EnergyTransferStoppedReason {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(EnergyTransferStoppedReason::Evstopped),
            1 => Some(EnergyTransferStoppedReason::Evsestopped),
            2 => Some(EnergyTransferStoppedReason::Other),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<EnergyTransferStoppedReason> for u8 {
    fn from(val: EnergyTransferStoppedReason) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum FaultState {
    /// The EVSE is not in an error state.
    Noerror = 0,
    /// The EVSE is unable to obtain electrical measurements.
    Meterfailure = 1,
    /// The EVSE input voltage level is too high.
    Overvoltage = 2,
    /// The EVSE input voltage level is too low.
    Undervoltage = 3,
    /// The EVSE detected charging current higher than allowed by charger.
    Overcurrent = 4,
    /// The EVSE detected voltage on charging pins when the contactor is open.
    Contactwetfailure = 5,
    /// The EVSE detected absence of voltage after enabling contactor.
    Contactdryfailure = 6,
    /// The EVSE has an unbalanced current supply.
    Groundfault = 7,
    /// The EVSE has detected a loss in power.
    Powerloss = 8,
    /// The EVSE has detected another power quality issue (e.g. phase imbalance).
    Powerquality = 9,
    /// The EVSE pilot signal amplitude short circuited to ground.
    Pilotshortcircuit = 10,
    /// The emergency stop button was pressed.
    Emergencystop = 11,
    /// The EVSE detected that the cable has been disconnected.
    Evdisconnected = 12,
    /// The EVSE could not determine proper power supply level.
    Wrongpowersupply = 13,
    /// The EVSE detected Live and Neutral are swapped.
    Liveneutralswap = 14,
    /// The EVSE internal temperature is too high.
    Overtemperature = 15,
    /// Any other reason.
    Other = 255,
}

impl FaultState {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(FaultState::Noerror),
            1 => Some(FaultState::Meterfailure),
            2 => Some(FaultState::Overvoltage),
            3 => Some(FaultState::Undervoltage),
            4 => Some(FaultState::Overcurrent),
            5 => Some(FaultState::Contactwetfailure),
            6 => Some(FaultState::Contactdryfailure),
            7 => Some(FaultState::Groundfault),
            8 => Some(FaultState::Powerloss),
            9 => Some(FaultState::Powerquality),
            10 => Some(FaultState::Pilotshortcircuit),
            11 => Some(FaultState::Emergencystop),
            12 => Some(FaultState::Evdisconnected),
            13 => Some(FaultState::Wrongpowersupply),
            14 => Some(FaultState::Liveneutralswap),
            15 => Some(FaultState::Overtemperature),
            255 => Some(FaultState::Other),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<FaultState> for u8 {
    fn from(val: FaultState) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum State {
    /// The EV is not plugged in.
    Notpluggedin = 0,
    /// The EV is plugged in, but not demanding current.
    Pluggedinnodemand = 1,
    /// The EV is plugged in and is demanding current, but EVSE is not allowing current to flow.
    Pluggedindemand = 2,
    /// The EV is plugged in, charging is in progress, and current is flowing
    Pluggedincharging = 3,
    /// The EV is plugged in, discharging is in progress, and current is flowing
    Pluggedindischarging = 4,
    /// The EVSE is transitioning from any plugged-in state to NotPluggedIn
    Sessionending = 5,
    /// There is a fault, further details in the FaultState attribute
    Fault = 6,
}

impl State {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(State::Notpluggedin),
            1 => Some(State::Pluggedinnodemand),
            2 => Some(State::Pluggedindemand),
            3 => Some(State::Pluggedincharging),
            4 => Some(State::Pluggedindischarging),
            5 => Some(State::Sessionending),
            6 => Some(State::Fault),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<State> for u8 {
    fn from(val: State) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum SupplyState {
    /// The EV is not currently allowed to charge or discharge
    Disabled = 0,
    /// The EV is currently allowed to charge
    Chargingenabled = 1,
    /// The EV is currently allowed to discharge
    Dischargingenabled = 2,
    /// The EV is not currently allowed to charge or discharge due to an error. The error must be cleared before operation can continue.
    Disablederror = 3,
    /// The EV is not currently allowed to charge or discharge due to self-diagnostics mode.
    Disableddiagnostics = 4,
    /// The EV is currently allowed to charge and discharge
    Enabled = 5,
}

impl SupplyState {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(SupplyState::Disabled),
            1 => Some(SupplyState::Chargingenabled),
            2 => Some(SupplyState::Dischargingenabled),
            3 => Some(SupplyState::Disablederror),
            4 => Some(SupplyState::Disableddiagnostics),
            5 => Some(SupplyState::Enabled),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<SupplyState> for u8 {
    fn from(val: SupplyState) -> Self {
        val as u8
    }
}

// Struct definitions

#[derive(Debug, serde::Serialize)]
pub struct ChargingTargetSchedule {
    pub day_of_week_for_sequence: Option<u8>,
    pub charging_targets: Option<Vec<ChargingTarget>>,
}

#[derive(Debug, serde::Serialize)]
pub struct ChargingTarget {
    pub target_time_minutes_past_midnight: Option<u16>,
    pub target_so_c: Option<u8>,
    pub added_energy: Option<u64>,
}

// Command encoders

/// Encode EnableCharging command (0x02)
pub fn encode_enable_charging(charging_enabled_until: Option<u64>, minimum_charge_current: u8, maximum_charge_current: u8) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt64(charging_enabled_until.unwrap_or(0))).into(),
        (1, tlv::TlvItemValueEnc::UInt8(minimum_charge_current)).into(),
        (2, tlv::TlvItemValueEnc::UInt8(maximum_charge_current)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode EnableDischarging command (0x03)
pub fn encode_enable_discharging(discharging_enabled_until: Option<u64>, maximum_discharge_current: u8) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt64(discharging_enabled_until.unwrap_or(0))).into(),
        (1, tlv::TlvItemValueEnc::UInt8(maximum_discharge_current)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode SetTargets command (0x05)
pub fn encode_set_targets(charging_target_schedules: Vec<ChargingTargetSchedule>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::StructAnon(charging_target_schedules.into_iter().map(|v| {
                    let mut fields = Vec::new();
                    if let Some(x) = v.day_of_week_for_sequence { fields.push((0, tlv::TlvItemValueEnc::UInt8(x as u8)).into()); }
                    if let Some(listv) = v.charging_targets {
                        let inner_vec: Vec<_> = listv.into_iter().map(|inner| {
                            let mut nested_fields = Vec::new();
                                if let Some(x) = inner.target_time_minutes_past_midnight { nested_fields.push((0, tlv::TlvItemValueEnc::UInt16(x as u16)).into()); }
                                // TODO: encoding for field target_so_c (percent) not implemented
                                if let Some(x) = inner.added_energy { nested_fields.push((2, tlv::TlvItemValueEnc::UInt64(x)).into()); }
                            (0, tlv::TlvItemValueEnc::StructInvisible(nested_fields)).into()
                        }).collect();
                        fields.push((1, tlv::TlvItemValueEnc::StructAnon(inner_vec)).into());
                    }
                    (0, tlv::TlvItemValueEnc::StructInvisible(fields)).into()
                }).collect())).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

// Attribute decoders

/// Decode State attribute (0x0000)
pub fn decode_state(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<State>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(State::from_u8(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode SupplyState attribute (0x0001)
pub fn decode_supply_state(inp: &tlv::TlvItemValue) -> anyhow::Result<SupplyState> {
    if let tlv::TlvItemValue::Int(v) = inp {
        SupplyState::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode FaultState attribute (0x0002)
pub fn decode_fault_state(inp: &tlv::TlvItemValue) -> anyhow::Result<FaultState> {
    if let tlv::TlvItemValue::Int(v) = inp {
        FaultState::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode ChargingEnabledUntil attribute (0x0003)
pub fn decode_charging_enabled_until(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u64>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v))
    } else {
        Ok(None)
    }
}

/// Decode DischargingEnabledUntil attribute (0x0004)
pub fn decode_discharging_enabled_until(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u64>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v))
    } else {
        Ok(None)
    }
}

/// Decode CircuitCapacity attribute (0x0005)
pub fn decode_circuit_capacity(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode MinimumChargeCurrent attribute (0x0006)
pub fn decode_minimum_charge_current(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode MaximumChargeCurrent attribute (0x0007)
pub fn decode_maximum_charge_current(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode MaximumDischargeCurrent attribute (0x0008)
pub fn decode_maximum_discharge_current(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode UserMaximumChargeCurrent attribute (0x0009)
pub fn decode_user_maximum_charge_current(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode RandomizationDelayWindow attribute (0x000A)
pub fn decode_randomization_delay_window(inp: &tlv::TlvItemValue) -> anyhow::Result<u32> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u32)
    } else {
        Err(anyhow::anyhow!("Expected UInt32"))
    }
}

/// Decode NextChargeStartTime attribute (0x0023)
pub fn decode_next_charge_start_time(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u64>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v))
    } else {
        Ok(None)
    }
}

/// Decode NextChargeTargetTime attribute (0x0024)
pub fn decode_next_charge_target_time(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u64>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v))
    } else {
        Ok(None)
    }
}

/// Decode NextChargeRequiredEnergy attribute (0x0025)
pub fn decode_next_charge_required_energy(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u64>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v))
    } else {
        Ok(None)
    }
}

/// Decode NextChargeTargetSoC attribute (0x0026)
pub fn decode_next_charge_target_so_c(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode ApproximateEVEfficiency attribute (0x0027)
pub fn decode_approximate_ev_efficiency(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u16>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u16))
    } else {
        Ok(None)
    }
}

/// Decode StateOfCharge attribute (0x0030)
pub fn decode_state_of_charge(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode BatteryCapacity attribute (0x0031)
pub fn decode_battery_capacity(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u64>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v))
    } else {
        Ok(None)
    }
}

/// Decode VehicleID attribute (0x0032)
pub fn decode_vehicle_id(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<String>> {
    if let tlv::TlvItemValue::String(v) = inp {
        Ok(Some(v.clone()))
    } else {
        Ok(None)
    }
}

/// Decode SessionID attribute (0x0040)
pub fn decode_session_id(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u32>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u32))
    } else {
        Ok(None)
    }
}

/// Decode SessionDuration attribute (0x0041)
pub fn decode_session_duration(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u32>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u32))
    } else {
        Ok(None)
    }
}

/// Decode SessionEnergyCharged attribute (0x0042)
pub fn decode_session_energy_charged(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u64>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v))
    } else {
        Ok(None)
    }
}

/// Decode SessionEnergyDischarged attribute (0x0043)
pub fn decode_session_energy_discharged(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u64>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v))
    } else {
        Ok(None)
    }
}


// JSON dispatcher function

/// Decode attribute value and return as JSON string
/// 
/// # Parameters
/// * `cluster_id` - The cluster identifier
/// * `attribute_id` - The attribute identifier
/// * `tlv_value` - The TLV value to decode
/// 
/// # Returns
/// JSON string representation of the decoded value or error
pub fn decode_attribute_json(cluster_id: u32, attribute_id: u32, tlv_value: &crate::tlv::TlvItemValue) -> String {
    // Verify this is the correct cluster
    if cluster_id != 0x0099 {
        return format!("{{\"error\": \"Invalid cluster ID. Expected 0x0099, got {}\"}}", cluster_id);
    }
    
    match attribute_id {
        0x0000 => {
            match decode_state(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0001 => {
            match decode_supply_state(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0002 => {
            match decode_fault_state(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0003 => {
            match decode_charging_enabled_until(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0004 => {
            match decode_discharging_enabled_until(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0005 => {
            match decode_circuit_capacity(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0006 => {
            match decode_minimum_charge_current(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0007 => {
            match decode_maximum_charge_current(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0008 => {
            match decode_maximum_discharge_current(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0009 => {
            match decode_user_maximum_charge_current(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000A => {
            match decode_randomization_delay_window(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0023 => {
            match decode_next_charge_start_time(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0024 => {
            match decode_next_charge_target_time(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0025 => {
            match decode_next_charge_required_energy(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0026 => {
            match decode_next_charge_target_so_c(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0027 => {
            match decode_approximate_ev_efficiency(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0030 => {
            match decode_state_of_charge(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0031 => {
            match decode_battery_capacity(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0032 => {
            match decode_vehicle_id(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0040 => {
            match decode_session_id(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0041 => {
            match decode_session_duration(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0042 => {
            match decode_session_energy_charged(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0043 => {
            match decode_session_energy_discharged(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        _ => format!("{{\"error\": \"Unknown attribute ID: {}\"}}", attribute_id),
    }
}

/// Get list of all attributes supported by this cluster
/// 
/// # Returns
/// Vector of tuples containing (attribute_id, attribute_name)
pub fn get_attribute_list() -> Vec<(u32, &'static str)> {
    vec![
        (0x0000, "State"),
        (0x0001, "SupplyState"),
        (0x0002, "FaultState"),
        (0x0003, "ChargingEnabledUntil"),
        (0x0004, "DischargingEnabledUntil"),
        (0x0005, "CircuitCapacity"),
        (0x0006, "MinimumChargeCurrent"),
        (0x0007, "MaximumChargeCurrent"),
        (0x0008, "MaximumDischargeCurrent"),
        (0x0009, "UserMaximumChargeCurrent"),
        (0x000A, "RandomizationDelayWindow"),
        (0x0023, "NextChargeStartTime"),
        (0x0024, "NextChargeTargetTime"),
        (0x0025, "NextChargeRequiredEnergy"),
        (0x0026, "NextChargeTargetSoC"),
        (0x0027, "ApproximateEVEfficiency"),
        (0x0030, "StateOfCharge"),
        (0x0031, "BatteryCapacity"),
        (0x0032, "VehicleID"),
        (0x0040, "SessionID"),
        (0x0041, "SessionDuration"),
        (0x0042, "SessionEnergyCharged"),
        (0x0043, "SessionEnergyDischarged"),
    ]
}

