//! Generated Matter TLV encoders and decoders for Power Source Cluster
//! Cluster ID: 0x002F
//!
//! This file is automatically generated from PowerSourceCluster.xml

use crate::tlv;
use anyhow;
use serde_json;


// Enum definitions

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum BatApprovedChemistry {
    /// Cell chemistry is unspecified or unknown
    Unspecified = 0,
    /// Cell chemistry is alkaline
    Alkaline = 1,
    /// Cell chemistry is lithium carbon fluoride
    Lithiumcarbonfluoride = 2,
    /// Cell chemistry is lithium chromium oxide
    Lithiumchromiumoxide = 3,
    /// Cell chemistry is lithium copper oxide
    Lithiumcopperoxide = 4,
    /// Cell chemistry is lithium iron disulfide
    Lithiumirondisulfide = 5,
    /// Cell chemistry is lithium manganese dioxide
    Lithiummanganesedioxide = 6,
    /// Cell chemistry is lithium thionyl chloride
    Lithiumthionylchloride = 7,
    /// Cell chemistry is magnesium
    Magnesium = 8,
    /// Cell chemistry is mercury oxide
    Mercuryoxide = 9,
    /// Cell chemistry is nickel oxyhydride
    Nickeloxyhydride = 10,
    /// Cell chemistry is silver oxide
    Silveroxide = 11,
    /// Cell chemistry is zinc air
    Zincair = 12,
    /// Cell chemistry is zinc carbon
    Zinccarbon = 13,
    /// Cell chemistry is zinc chloride
    Zincchloride = 14,
    /// Cell chemistry is zinc manganese dioxide
    Zincmanganesedioxide = 15,
    /// Cell chemistry is lead acid
    Leadacid = 16,
    /// Cell chemistry is lithium cobalt oxide
    Lithiumcobaltoxide = 17,
    /// Cell chemistry is lithium ion
    Lithiumion = 18,
    /// Cell chemistry is lithium ion polymer
    Lithiumionpolymer = 19,
    /// Cell chemistry is lithium iron phosphate
    Lithiumironphosphate = 20,
    /// Cell chemistry is lithium sulfur
    Lithiumsulfur = 21,
    /// Cell chemistry is lithium titanate
    Lithiumtitanate = 22,
    /// Cell chemistry is nickel cadmium
    Nickelcadmium = 23,
    /// Cell chemistry is nickel hydrogen
    Nickelhydrogen = 24,
    /// Cell chemistry is nickel iron
    Nickeliron = 25,
    /// Cell chemistry is nickel metal hydride
    Nickelmetalhydride = 26,
    /// Cell chemistry is nickel zinc
    Nickelzinc = 27,
    /// Cell chemistry is silver zinc
    Silverzinc = 28,
    /// Cell chemistry is sodium ion
    Sodiumion = 29,
    /// Cell chemistry is sodium sulfur
    Sodiumsulfur = 30,
    /// Cell chemistry is zinc bromide
    Zincbromide = 31,
    /// Cell chemistry is zinc cerium
    Zinccerium = 32,
}

impl BatApprovedChemistry {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(BatApprovedChemistry::Unspecified),
            1 => Some(BatApprovedChemistry::Alkaline),
            2 => Some(BatApprovedChemistry::Lithiumcarbonfluoride),
            3 => Some(BatApprovedChemistry::Lithiumchromiumoxide),
            4 => Some(BatApprovedChemistry::Lithiumcopperoxide),
            5 => Some(BatApprovedChemistry::Lithiumirondisulfide),
            6 => Some(BatApprovedChemistry::Lithiummanganesedioxide),
            7 => Some(BatApprovedChemistry::Lithiumthionylchloride),
            8 => Some(BatApprovedChemistry::Magnesium),
            9 => Some(BatApprovedChemistry::Mercuryoxide),
            10 => Some(BatApprovedChemistry::Nickeloxyhydride),
            11 => Some(BatApprovedChemistry::Silveroxide),
            12 => Some(BatApprovedChemistry::Zincair),
            13 => Some(BatApprovedChemistry::Zinccarbon),
            14 => Some(BatApprovedChemistry::Zincchloride),
            15 => Some(BatApprovedChemistry::Zincmanganesedioxide),
            16 => Some(BatApprovedChemistry::Leadacid),
            17 => Some(BatApprovedChemistry::Lithiumcobaltoxide),
            18 => Some(BatApprovedChemistry::Lithiumion),
            19 => Some(BatApprovedChemistry::Lithiumionpolymer),
            20 => Some(BatApprovedChemistry::Lithiumironphosphate),
            21 => Some(BatApprovedChemistry::Lithiumsulfur),
            22 => Some(BatApprovedChemistry::Lithiumtitanate),
            23 => Some(BatApprovedChemistry::Nickelcadmium),
            24 => Some(BatApprovedChemistry::Nickelhydrogen),
            25 => Some(BatApprovedChemistry::Nickeliron),
            26 => Some(BatApprovedChemistry::Nickelmetalhydride),
            27 => Some(BatApprovedChemistry::Nickelzinc),
            28 => Some(BatApprovedChemistry::Silverzinc),
            29 => Some(BatApprovedChemistry::Sodiumion),
            30 => Some(BatApprovedChemistry::Sodiumsulfur),
            31 => Some(BatApprovedChemistry::Zincbromide),
            32 => Some(BatApprovedChemistry::Zinccerium),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<BatApprovedChemistry> for u8 {
    fn from(val: BatApprovedChemistry) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum BatChargeFault {
    /// The Node detects an unspecified fault on this battery source.
    Unspecified = 0,
    /// The Node detects the ambient temperature is above the nominal range for this battery source.
    Ambienttoohot = 1,
    /// The Node detects the ambient temperature is below the nominal range for this battery source.
    Ambienttoocold = 2,
    /// The Node detects the temperature of this battery source is above the nominal range.
    Batterytoohot = 3,
    /// The Node detects the temperature of this battery source is below the nominal range.
    Batterytoocold = 4,
    /// The Node detects this battery source is not present.
    Batteryabsent = 5,
    /// The Node detects this battery source is over voltage.
    Batteryovervoltage = 6,
    /// The Node detects this battery source is under voltage.
    Batteryundervoltage = 7,
    /// The Node detects the charger for this battery source is over voltage.
    Chargerovervoltage = 8,
    /// The Node detects the charger for this battery source is under voltage.
    Chargerundervoltage = 9,
    /// The Node detects a charging safety timeout for this battery source.
    Safetytimeout = 10,
}

impl BatChargeFault {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(BatChargeFault::Unspecified),
            1 => Some(BatChargeFault::Ambienttoohot),
            2 => Some(BatChargeFault::Ambienttoocold),
            3 => Some(BatChargeFault::Batterytoohot),
            4 => Some(BatChargeFault::Batterytoocold),
            5 => Some(BatChargeFault::Batteryabsent),
            6 => Some(BatChargeFault::Batteryovervoltage),
            7 => Some(BatChargeFault::Batteryundervoltage),
            8 => Some(BatChargeFault::Chargerovervoltage),
            9 => Some(BatChargeFault::Chargerundervoltage),
            10 => Some(BatChargeFault::Safetytimeout),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<BatChargeFault> for u8 {
    fn from(val: BatChargeFault) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum BatChargeLevel {
    /// Charge level is nominal
    Ok = 0,
    /// Charge level is low, intervention may soon be required.
    Warning = 1,
    /// Charge level is critical, immediate intervention is required
    Critical = 2,
}

impl BatChargeLevel {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(BatChargeLevel::Ok),
            1 => Some(BatChargeLevel::Warning),
            2 => Some(BatChargeLevel::Critical),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<BatChargeLevel> for u8 {
    fn from(val: BatChargeLevel) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum BatChargeState {
    /// Unable to determine the charging state
    Unknown = 0,
    /// The battery is charging
    Ischarging = 1,
    /// The battery is at full charge
    Isatfullcharge = 2,
    /// The battery is not charging
    Isnotcharging = 3,
}

impl BatChargeState {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(BatChargeState::Unknown),
            1 => Some(BatChargeState::Ischarging),
            2 => Some(BatChargeState::Isatfullcharge),
            3 => Some(BatChargeState::Isnotcharging),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<BatChargeState> for u8 {
    fn from(val: BatChargeState) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum BatCommonDesignation {
    /// Common type is unknown or unspecified
    Unspecified = 0,
    /// Common type is as specified
    Aaa = 1,
    /// Common type is as specified
    Aa = 2,
    /// Common type is as specified
    C = 3,
    /// Common type is as specified
    D = 4,
    /// Common type is as specified
    _4v5 = 5,
    /// Common type is as specified
    _6v0 = 6,
    /// Common type is as specified
    _9v0 = 7,
    /// Common type is as specified
    _12aa = 8,
    /// Common type is as specified
    Aaaa = 9,
    /// Common type is as specified
    A = 10,
    /// Common type is as specified
    B = 11,
    /// Common type is as specified
    F = 12,
    /// Common type is as specified
    N = 13,
    /// Common type is as specified
    No6 = 14,
    /// Common type is as specified
    Subc = 15,
    /// Common type is as specified
    A23 = 16,
    /// Common type is as specified
    A27 = 17,
    /// Common type is as specified
    Ba5800 = 18,
    /// Common type is as specified
    Duplex = 19,
    /// Common type is as specified
    _4sr44 = 20,
    /// Common type is as specified
    _523 = 21,
    /// Common type is as specified
    _531 = 22,
    /// Common type is as specified
    _15v0 = 23,
    /// Common type is as specified
    _22v5 = 24,
    /// Common type is as specified
    _30v0 = 25,
    /// Common type is as specified
    _45v0 = 26,
    /// Common type is as specified
    _67v5 = 27,
    /// Common type is as specified
    J = 28,
    /// Common type is as specified
    Cr123a = 29,
    /// Common type is as specified
    Cr2 = 30,
    /// Common type is as specified
    _2cr5 = 31,
    /// Common type is as specified
    CrP2 = 32,
    /// Common type is as specified
    CrV3 = 33,
    /// Common type is as specified
    Sr41 = 34,
    /// Common type is as specified
    Sr43 = 35,
    /// Common type is as specified
    Sr44 = 36,
    /// Common type is as specified
    Sr45 = 37,
    /// Common type is as specified
    Sr48 = 38,
    /// Common type is as specified
    Sr54 = 39,
    /// Common type is as specified
    Sr55 = 40,
    /// Common type is as specified
    Sr57 = 41,
    /// Common type is as specified
    Sr58 = 42,
    /// Common type is as specified
    Sr59 = 43,
    /// Common type is as specified
    Sr60 = 44,
    /// Common type is as specified
    Sr63 = 45,
    /// Common type is as specified
    Sr64 = 46,
    /// Common type is as specified
    Sr65 = 47,
    /// Common type is as specified
    Sr66 = 48,
    /// Common type is as specified
    Sr67 = 49,
    /// Common type is as specified
    Sr68 = 50,
    /// Common type is as specified
    Sr69 = 51,
    /// Common type is as specified
    Sr516 = 52,
    /// Common type is as specified
    Sr731 = 53,
    /// Common type is as specified
    Sr712 = 54,
    /// Common type is as specified
    Lr932 = 55,
    /// Common type is as specified
    A5 = 56,
    /// Common type is as specified
    A10 = 57,
    /// Common type is as specified
    A13 = 58,
    /// Common type is as specified
    A312 = 59,
    /// Common type is as specified
    A675 = 60,
    /// Common type is as specified
    Ac41e = 61,
    /// Common type is as specified
    _10180 = 62,
    /// Common type is as specified
    _10280 = 63,
    /// Common type is as specified
    _10440 = 64,
    /// Common type is as specified
    _14250 = 65,
    /// Common type is as specified
    _14430 = 66,
    /// Common type is as specified
    _14500 = 67,
    /// Common type is as specified
    _14650 = 68,
    /// Common type is as specified
    _15270 = 69,
    /// Common type is as specified
    _16340 = 70,
    /// Common type is as specified
    Rcr123a = 71,
    /// Common type is as specified
    _17500 = 72,
    /// Common type is as specified
    _17670 = 73,
    /// Common type is as specified
    _18350 = 74,
    /// Common type is as specified
    _18500 = 75,
    /// Common type is as specified
    _18650 = 76,
    /// Common type is as specified
    _19670 = 77,
    /// Common type is as specified
    _25500 = 78,
    /// Common type is as specified
    _26650 = 79,
    /// Common type is as specified
    _32600 = 80,
}

impl BatCommonDesignation {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(BatCommonDesignation::Unspecified),
            1 => Some(BatCommonDesignation::Aaa),
            2 => Some(BatCommonDesignation::Aa),
            3 => Some(BatCommonDesignation::C),
            4 => Some(BatCommonDesignation::D),
            5 => Some(BatCommonDesignation::_4v5),
            6 => Some(BatCommonDesignation::_6v0),
            7 => Some(BatCommonDesignation::_9v0),
            8 => Some(BatCommonDesignation::_12aa),
            9 => Some(BatCommonDesignation::Aaaa),
            10 => Some(BatCommonDesignation::A),
            11 => Some(BatCommonDesignation::B),
            12 => Some(BatCommonDesignation::F),
            13 => Some(BatCommonDesignation::N),
            14 => Some(BatCommonDesignation::No6),
            15 => Some(BatCommonDesignation::Subc),
            16 => Some(BatCommonDesignation::A23),
            17 => Some(BatCommonDesignation::A27),
            18 => Some(BatCommonDesignation::Ba5800),
            19 => Some(BatCommonDesignation::Duplex),
            20 => Some(BatCommonDesignation::_4sr44),
            21 => Some(BatCommonDesignation::_523),
            22 => Some(BatCommonDesignation::_531),
            23 => Some(BatCommonDesignation::_15v0),
            24 => Some(BatCommonDesignation::_22v5),
            25 => Some(BatCommonDesignation::_30v0),
            26 => Some(BatCommonDesignation::_45v0),
            27 => Some(BatCommonDesignation::_67v5),
            28 => Some(BatCommonDesignation::J),
            29 => Some(BatCommonDesignation::Cr123a),
            30 => Some(BatCommonDesignation::Cr2),
            31 => Some(BatCommonDesignation::_2cr5),
            32 => Some(BatCommonDesignation::CrP2),
            33 => Some(BatCommonDesignation::CrV3),
            34 => Some(BatCommonDesignation::Sr41),
            35 => Some(BatCommonDesignation::Sr43),
            36 => Some(BatCommonDesignation::Sr44),
            37 => Some(BatCommonDesignation::Sr45),
            38 => Some(BatCommonDesignation::Sr48),
            39 => Some(BatCommonDesignation::Sr54),
            40 => Some(BatCommonDesignation::Sr55),
            41 => Some(BatCommonDesignation::Sr57),
            42 => Some(BatCommonDesignation::Sr58),
            43 => Some(BatCommonDesignation::Sr59),
            44 => Some(BatCommonDesignation::Sr60),
            45 => Some(BatCommonDesignation::Sr63),
            46 => Some(BatCommonDesignation::Sr64),
            47 => Some(BatCommonDesignation::Sr65),
            48 => Some(BatCommonDesignation::Sr66),
            49 => Some(BatCommonDesignation::Sr67),
            50 => Some(BatCommonDesignation::Sr68),
            51 => Some(BatCommonDesignation::Sr69),
            52 => Some(BatCommonDesignation::Sr516),
            53 => Some(BatCommonDesignation::Sr731),
            54 => Some(BatCommonDesignation::Sr712),
            55 => Some(BatCommonDesignation::Lr932),
            56 => Some(BatCommonDesignation::A5),
            57 => Some(BatCommonDesignation::A10),
            58 => Some(BatCommonDesignation::A13),
            59 => Some(BatCommonDesignation::A312),
            60 => Some(BatCommonDesignation::A675),
            61 => Some(BatCommonDesignation::Ac41e),
            62 => Some(BatCommonDesignation::_10180),
            63 => Some(BatCommonDesignation::_10280),
            64 => Some(BatCommonDesignation::_10440),
            65 => Some(BatCommonDesignation::_14250),
            66 => Some(BatCommonDesignation::_14430),
            67 => Some(BatCommonDesignation::_14500),
            68 => Some(BatCommonDesignation::_14650),
            69 => Some(BatCommonDesignation::_15270),
            70 => Some(BatCommonDesignation::_16340),
            71 => Some(BatCommonDesignation::Rcr123a),
            72 => Some(BatCommonDesignation::_17500),
            73 => Some(BatCommonDesignation::_17670),
            74 => Some(BatCommonDesignation::_18350),
            75 => Some(BatCommonDesignation::_18500),
            76 => Some(BatCommonDesignation::_18650),
            77 => Some(BatCommonDesignation::_19670),
            78 => Some(BatCommonDesignation::_25500),
            79 => Some(BatCommonDesignation::_26650),
            80 => Some(BatCommonDesignation::_32600),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<BatCommonDesignation> for u8 {
    fn from(val: BatCommonDesignation) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum BatFault {
    /// The Node detects an unspecified fault on this battery power source.
    Unspecified = 0,
    /// The Node detects the temperature of this battery power source is above ideal operating conditions.
    Overtemp = 1,
    /// The Node detects the temperature of this battery power source is below ideal operating conditions.
    Undertemp = 2,
}

impl BatFault {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(BatFault::Unspecified),
            1 => Some(BatFault::Overtemp),
            2 => Some(BatFault::Undertemp),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<BatFault> for u8 {
    fn from(val: BatFault) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum BatReplaceability {
    /// The replaceability is unspecified or unknown.
    Unspecified = 0,
    /// The battery is not replaceable.
    Notreplaceable = 1,
    /// The battery is replaceable by the user or customer.
    Userreplaceable = 2,
    /// The battery is replaceable by an authorized factory technician.
    Factoryreplaceable = 3,
}

impl BatReplaceability {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(BatReplaceability::Unspecified),
            1 => Some(BatReplaceability::Notreplaceable),
            2 => Some(BatReplaceability::Userreplaceable),
            3 => Some(BatReplaceability::Factoryreplaceable),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<BatReplaceability> for u8 {
    fn from(val: BatReplaceability) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum PowerSourceStatus {
    /// Indicate the source status is not specified
    Unspecified = 0,
    /// Indicate the source is available and currently supplying power
    Active = 1,
    /// Indicate the source is available, but is not currently supplying power
    Standby = 2,
    /// Indicate the source is not currently available to supply power
    Unavailable = 3,
}

impl PowerSourceStatus {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(PowerSourceStatus::Unspecified),
            1 => Some(PowerSourceStatus::Active),
            2 => Some(PowerSourceStatus::Standby),
            3 => Some(PowerSourceStatus::Unavailable),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<PowerSourceStatus> for u8 {
    fn from(val: PowerSourceStatus) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum WiredCurrentType {
    /// Indicates AC current
    Ac = 0,
    /// Indicates DC current
    Dc = 1,
}

impl WiredCurrentType {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(WiredCurrentType::Ac),
            1 => Some(WiredCurrentType::Dc),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<WiredCurrentType> for u8 {
    fn from(val: WiredCurrentType) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum WiredFault {
    /// The Node detects an unspecified fault on this wired power source.
    Unspecified = 0,
    /// The Node detects the supplied voltage is above maximum supported value for this wired power source.
    Overvoltage = 1,
    /// The Node detects the supplied voltage is below maximum supported value for this wired power source.
    Undervoltage = 2,
}

impl WiredFault {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(WiredFault::Unspecified),
            1 => Some(WiredFault::Overvoltage),
            2 => Some(WiredFault::Undervoltage),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<WiredFault> for u8 {
    fn from(val: WiredFault) -> Self {
        val as u8
    }
}

// Attribute decoders

/// Decode Status attribute (0x0000)
pub fn decode_status(inp: &tlv::TlvItemValue) -> anyhow::Result<PowerSourceStatus> {
    if let tlv::TlvItemValue::Int(v) = inp {
        PowerSourceStatus::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode Order attribute (0x0001)
pub fn decode_order(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode Description attribute (0x0002)
pub fn decode_description(inp: &tlv::TlvItemValue) -> anyhow::Result<String> {
    if let tlv::TlvItemValue::String(v) = inp {
        Ok(v.clone())
    } else {
        Err(anyhow::anyhow!("Expected String"))
    }
}

/// Decode WiredAssessedInputVoltage attribute (0x0003)
pub fn decode_wired_assessed_input_voltage(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u32>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u32))
    } else {
        Ok(None)
    }
}

/// Decode WiredAssessedInputFrequency attribute (0x0004)
pub fn decode_wired_assessed_input_frequency(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u16>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u16))
    } else {
        Ok(None)
    }
}

/// Decode WiredCurrentType attribute (0x0005)
pub fn decode_wired_current_type(inp: &tlv::TlvItemValue) -> anyhow::Result<WiredCurrentType> {
    if let tlv::TlvItemValue::Int(v) = inp {
        WiredCurrentType::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode WiredAssessedCurrent attribute (0x0006)
pub fn decode_wired_assessed_current(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u32>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u32))
    } else {
        Ok(None)
    }
}

/// Decode WiredNominalVoltage attribute (0x0007)
pub fn decode_wired_nominal_voltage(inp: &tlv::TlvItemValue) -> anyhow::Result<u32> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u32)
    } else {
        Err(anyhow::anyhow!("Expected UInt32"))
    }
}

/// Decode WiredMaximumCurrent attribute (0x0008)
pub fn decode_wired_maximum_current(inp: &tlv::TlvItemValue) -> anyhow::Result<u32> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u32)
    } else {
        Err(anyhow::anyhow!("Expected UInt32"))
    }
}

/// Decode WiredPresent attribute (0x0009)
pub fn decode_wired_present(inp: &tlv::TlvItemValue) -> anyhow::Result<bool> {
    if let tlv::TlvItemValue::Bool(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected Bool"))
    }
}

/// Decode ActiveWiredFaults attribute (0x000A)
pub fn decode_active_wired_faults(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<WiredFault>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            if let tlv::TlvItemValue::Int(i) = &item.value {
                if let Some(enum_val) = WiredFault::from_u8(*i as u8) {
                    res.push(enum_val);
                }
            }
        }
    }
    Ok(res)
}

/// Decode BatVoltage attribute (0x000B)
pub fn decode_bat_voltage(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u32>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u32))
    } else {
        Ok(None)
    }
}

/// Decode BatPercentRemaining attribute (0x000C)
pub fn decode_bat_percent_remaining(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u8>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u8))
    } else {
        Ok(None)
    }
}

/// Decode BatTimeRemaining attribute (0x000D)
pub fn decode_bat_time_remaining(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u32>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u32))
    } else {
        Ok(None)
    }
}

/// Decode BatChargeLevel attribute (0x000E)
pub fn decode_bat_charge_level(inp: &tlv::TlvItemValue) -> anyhow::Result<BatChargeLevel> {
    if let tlv::TlvItemValue::Int(v) = inp {
        BatChargeLevel::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode BatReplacementNeeded attribute (0x000F)
pub fn decode_bat_replacement_needed(inp: &tlv::TlvItemValue) -> anyhow::Result<bool> {
    if let tlv::TlvItemValue::Bool(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected Bool"))
    }
}

/// Decode BatReplaceability attribute (0x0010)
pub fn decode_bat_replaceability(inp: &tlv::TlvItemValue) -> anyhow::Result<BatReplaceability> {
    if let tlv::TlvItemValue::Int(v) = inp {
        BatReplaceability::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode BatPresent attribute (0x0011)
pub fn decode_bat_present(inp: &tlv::TlvItemValue) -> anyhow::Result<bool> {
    if let tlv::TlvItemValue::Bool(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected Bool"))
    }
}

/// Decode ActiveBatFaults attribute (0x0012)
pub fn decode_active_bat_faults(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<BatFault>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            if let tlv::TlvItemValue::Int(i) = &item.value {
                if let Some(enum_val) = BatFault::from_u8(*i as u8) {
                    res.push(enum_val);
                }
            }
        }
    }
    Ok(res)
}

/// Decode BatReplacementDescription attribute (0x0013)
pub fn decode_bat_replacement_description(inp: &tlv::TlvItemValue) -> anyhow::Result<String> {
    if let tlv::TlvItemValue::String(v) = inp {
        Ok(v.clone())
    } else {
        Err(anyhow::anyhow!("Expected String"))
    }
}

/// Decode BatCommonDesignation attribute (0x0014)
pub fn decode_bat_common_designation(inp: &tlv::TlvItemValue) -> anyhow::Result<BatCommonDesignation> {
    if let tlv::TlvItemValue::Int(v) = inp {
        BatCommonDesignation::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode BatANSIDesignation attribute (0x0015)
pub fn decode_bat_ansi_designation(inp: &tlv::TlvItemValue) -> anyhow::Result<String> {
    if let tlv::TlvItemValue::String(v) = inp {
        Ok(v.clone())
    } else {
        Err(anyhow::anyhow!("Expected String"))
    }
}

/// Decode BatIECDesignation attribute (0x0016)
pub fn decode_bat_iec_designation(inp: &tlv::TlvItemValue) -> anyhow::Result<String> {
    if let tlv::TlvItemValue::String(v) = inp {
        Ok(v.clone())
    } else {
        Err(anyhow::anyhow!("Expected String"))
    }
}

/// Decode BatApprovedChemistry attribute (0x0017)
pub fn decode_bat_approved_chemistry(inp: &tlv::TlvItemValue) -> anyhow::Result<BatApprovedChemistry> {
    if let tlv::TlvItemValue::Int(v) = inp {
        BatApprovedChemistry::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode BatCapacity attribute (0x0018)
pub fn decode_bat_capacity(inp: &tlv::TlvItemValue) -> anyhow::Result<u32> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u32)
    } else {
        Err(anyhow::anyhow!("Expected UInt32"))
    }
}

/// Decode BatQuantity attribute (0x0019)
pub fn decode_bat_quantity(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode BatChargeState attribute (0x001A)
pub fn decode_bat_charge_state(inp: &tlv::TlvItemValue) -> anyhow::Result<BatChargeState> {
    if let tlv::TlvItemValue::Int(v) = inp {
        BatChargeState::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode BatTimeToFullCharge attribute (0x001B)
pub fn decode_bat_time_to_full_charge(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u32>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u32))
    } else {
        Ok(None)
    }
}

/// Decode BatFunctionalWhileCharging attribute (0x001C)
pub fn decode_bat_functional_while_charging(inp: &tlv::TlvItemValue) -> anyhow::Result<bool> {
    if let tlv::TlvItemValue::Bool(v) = inp {
        Ok(*v)
    } else {
        Err(anyhow::anyhow!("Expected Bool"))
    }
}

/// Decode BatChargingCurrent attribute (0x001D)
pub fn decode_bat_charging_current(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<u32>> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(Some(*v as u32))
    } else {
        Ok(None)
    }
}

/// Decode ActiveBatChargeFaults attribute (0x001E)
pub fn decode_active_bat_charge_faults(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<BatChargeFault>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            if let tlv::TlvItemValue::Int(i) = &item.value {
                if let Some(enum_val) = BatChargeFault::from_u8(*i as u8) {
                    res.push(enum_val);
                }
            }
        }
    }
    Ok(res)
}

/// Decode EndpointList attribute (0x001F)
pub fn decode_endpoint_list(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<u16>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            if let tlv::TlvItemValue::Int(i) = &item.value {
                res.push(*i as u16);
            }
        }
    }
    Ok(res)
}


// JSON dispatcher function

/// Decode attribute value and return as JSON string
/// 
/// # Parameters
/// * `cluster_id` - The cluster identifier
/// * `attribute_id` - The attribute identifier
/// * `tlv_value` - The TLV value to decode
/// 
/// # Returns
/// JSON string representation of the decoded value or error
pub fn decode_attribute_json(cluster_id: u32, attribute_id: u32, tlv_value: &crate::tlv::TlvItemValue) -> String {
    // Verify this is the correct cluster
    if cluster_id != 0x002F {
        return format!("{{\"error\": \"Invalid cluster ID. Expected 0x002F, got {}\"}}", cluster_id);
    }
    
    match attribute_id {
        0x0000 => {
            match decode_status(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0001 => {
            match decode_order(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0002 => {
            match decode_description(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0003 => {
            match decode_wired_assessed_input_voltage(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0004 => {
            match decode_wired_assessed_input_frequency(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0005 => {
            match decode_wired_current_type(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0006 => {
            match decode_wired_assessed_current(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0007 => {
            match decode_wired_nominal_voltage(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0008 => {
            match decode_wired_maximum_current(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0009 => {
            match decode_wired_present(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000A => {
            match decode_active_wired_faults(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000B => {
            match decode_bat_voltage(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000C => {
            match decode_bat_percent_remaining(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000D => {
            match decode_bat_time_remaining(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000E => {
            match decode_bat_charge_level(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000F => {
            match decode_bat_replacement_needed(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0010 => {
            match decode_bat_replaceability(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0011 => {
            match decode_bat_present(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0012 => {
            match decode_active_bat_faults(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0013 => {
            match decode_bat_replacement_description(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0014 => {
            match decode_bat_common_designation(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0015 => {
            match decode_bat_ansi_designation(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0016 => {
            match decode_bat_iec_designation(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0017 => {
            match decode_bat_approved_chemistry(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0018 => {
            match decode_bat_capacity(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0019 => {
            match decode_bat_quantity(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x001A => {
            match decode_bat_charge_state(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x001B => {
            match decode_bat_time_to_full_charge(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x001C => {
            match decode_bat_functional_while_charging(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x001D => {
            match decode_bat_charging_current(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x001E => {
            match decode_active_bat_charge_faults(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x001F => {
            match decode_endpoint_list(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        _ => format!("{{\"error\": \"Unknown attribute ID: {}\"}}", attribute_id),
    }
}

/// Get list of all attributes supported by this cluster
/// 
/// # Returns
/// Vector of tuples containing (attribute_id, attribute_name)
pub fn get_attribute_list() -> Vec<(u32, &'static str)> {
    vec![
        (0x0000, "Status"),
        (0x0001, "Order"),
        (0x0002, "Description"),
        (0x0003, "WiredAssessedInputVoltage"),
        (0x0004, "WiredAssessedInputFrequency"),
        (0x0005, "WiredCurrentType"),
        (0x0006, "WiredAssessedCurrent"),
        (0x0007, "WiredNominalVoltage"),
        (0x0008, "WiredMaximumCurrent"),
        (0x0009, "WiredPresent"),
        (0x000A, "ActiveWiredFaults"),
        (0x000B, "BatVoltage"),
        (0x000C, "BatPercentRemaining"),
        (0x000D, "BatTimeRemaining"),
        (0x000E, "BatChargeLevel"),
        (0x000F, "BatReplacementNeeded"),
        (0x0010, "BatReplaceability"),
        (0x0011, "BatPresent"),
        (0x0012, "ActiveBatFaults"),
        (0x0013, "BatReplacementDescription"),
        (0x0014, "BatCommonDesignation"),
        (0x0015, "BatANSIDesignation"),
        (0x0016, "BatIECDesignation"),
        (0x0017, "BatApprovedChemistry"),
        (0x0018, "BatCapacity"),
        (0x0019, "BatQuantity"),
        (0x001A, "BatChargeState"),
        (0x001B, "BatTimeToFullCharge"),
        (0x001C, "BatFunctionalWhileCharging"),
        (0x001D, "BatChargingCurrent"),
        (0x001E, "ActiveBatChargeFaults"),
        (0x001F, "EndpointList"),
    ]
}

