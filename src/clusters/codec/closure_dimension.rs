//! Generated Matter TLV encoders and decoders for Closure Dimension Cluster
//! Cluster ID: 0x0105
//!
//! This file is automatically generated from ClosureDimension.xml

use crate::tlv;
use anyhow;
use serde_json;


// Enum definitions

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ClosureUnit {
    /// Millimeter used as unit
    Millimeter = 0,
    /// Degree used as unit
    Degree = 1,
}

impl ClosureUnit {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(ClosureUnit::Millimeter),
            1 => Some(ClosureUnit::Degree),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<ClosureUnit> for u8 {
    fn from(val: ClosureUnit) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ModulationType {
    /// Orientation of the slats
    Slatsorientation = 0,
    /// Aperture of the slats
    Slatsopenwork = 1,
    /// Alignment of blind stripes (Zebra)
    Stripesalignment = 2,
    /// Opacity of a surface
    Opacity = 3,
    /// Ventilation control
    Ventilation = 4,
}

impl ModulationType {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(ModulationType::Slatsorientation),
            1 => Some(ModulationType::Slatsopenwork),
            2 => Some(ModulationType::Stripesalignment),
            3 => Some(ModulationType::Opacity),
            4 => Some(ModulationType::Ventilation),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<ModulationType> for u8 {
    fn from(val: ModulationType) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum Overflow {
    /// No overflow
    Nooverflow = 0,
    /// Inside overflow
    Inside = 1,
    /// Outside overflow
    Outside = 2,
    /// Top inside overflow
    Topinside = 3,
    /// Top outside overflow
    Topoutside = 4,
    /// Bottom inside overflow
    Bottominside = 5,
    /// Bottom outside overflow
    Bottomoutside = 6,
    /// Left inside overflow
    Leftinside = 7,
    /// Left outside overflow
    Leftoutside = 8,
    /// Right inside overflow
    Rightinside = 9,
    /// Right outside overflow
    Rightoutside = 10,
}

impl Overflow {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(Overflow::Nooverflow),
            1 => Some(Overflow::Inside),
            2 => Some(Overflow::Outside),
            3 => Some(Overflow::Topinside),
            4 => Some(Overflow::Topoutside),
            5 => Some(Overflow::Bottominside),
            6 => Some(Overflow::Bottomoutside),
            7 => Some(Overflow::Leftinside),
            8 => Some(Overflow::Leftoutside),
            9 => Some(Overflow::Rightinside),
            10 => Some(Overflow::Rightoutside),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<Overflow> for u8 {
    fn from(val: Overflow) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum RotationAxis {
    /// The panel rotates around a vertical axis located on the left side of the panel
    Left = 0,
    /// The panel rotates around a vertical axis located in the center of the panel
    Centeredvertical = 1,
    /// The panels rotates around vertical axes located on the left and right sides of the panel
    Leftandright = 2,
    /// The panel rotates around a vertical axis located on the right side of the panel
    Right = 3,
    /// The panel rotates around a horizontal axis located on the top of the panel
    Top = 4,
    /// The panel rotates around a horizontal axis located in the center of the panel
    Centeredhorizontal = 5,
    /// The panels rotates around horizontal axes located on the top and bottom of the panel
    Topandbottom = 6,
    /// The panel rotates around a horizontal axis located on the bottom of the panel
    Bottom = 7,
    /// The barrier tilts around an axis located at the left end of the barrier
    Leftbarrier = 8,
    /// The dual barriers tilt around axes located at each side of the composite barrier
    Leftandrightbarriers = 9,
    /// The barrier tilts around an axis located at the right end of the barrier
    Rightbarrier = 10,
}

impl RotationAxis {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(RotationAxis::Left),
            1 => Some(RotationAxis::Centeredvertical),
            2 => Some(RotationAxis::Leftandright),
            3 => Some(RotationAxis::Right),
            4 => Some(RotationAxis::Top),
            5 => Some(RotationAxis::Centeredhorizontal),
            6 => Some(RotationAxis::Topandbottom),
            7 => Some(RotationAxis::Bottom),
            8 => Some(RotationAxis::Leftbarrier),
            9 => Some(RotationAxis::Leftandrightbarriers),
            10 => Some(RotationAxis::Rightbarrier),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<RotationAxis> for u8 {
    fn from(val: RotationAxis) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum StepDirection {
    /// Decrease towards 0.00%
    Decrease = 0,
    /// Increase towards 100.00%
    Increase = 1,
}

impl StepDirection {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(StepDirection::Decrease),
            1 => Some(StepDirection::Increase),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<StepDirection> for u8 {
    fn from(val: StepDirection) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum TranslationDirection {
    /// Downward translation
    Downward = 0,
    /// Upward translation
    Upward = 1,
    /// Vertical mask translation
    Verticalmask = 2,
    /// Vertical symmetry translation
    Verticalsymmetry = 3,
    /// Leftward translation
    Leftward = 4,
    /// Rightward translation
    Rightward = 5,
    /// Horizontal mask translation
    Horizontalmask = 6,
    /// Horizontal symmetry translation
    Horizontalsymmetry = 7,
    /// Forward translation
    Forward = 8,
    /// Backward translation
    Backward = 9,
    /// Depth mask translation
    Depthmask = 10,
    /// Depth symmetry translation
    Depthsymmetry = 11,
}

impl TranslationDirection {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(TranslationDirection::Downward),
            1 => Some(TranslationDirection::Upward),
            2 => Some(TranslationDirection::Verticalmask),
            3 => Some(TranslationDirection::Verticalsymmetry),
            4 => Some(TranslationDirection::Leftward),
            5 => Some(TranslationDirection::Rightward),
            6 => Some(TranslationDirection::Horizontalmask),
            7 => Some(TranslationDirection::Horizontalsymmetry),
            8 => Some(TranslationDirection::Forward),
            9 => Some(TranslationDirection::Backward),
            10 => Some(TranslationDirection::Depthmask),
            11 => Some(TranslationDirection::Depthsymmetry),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<TranslationDirection> for u8 {
    fn from(val: TranslationDirection) -> Self {
        val as u8
    }
}

// Bitmap definitions

/// LatchControlModes bitmap type
pub type LatchControlModes = u8;

/// Constants for LatchControlModes
pub mod latchcontrolmodes {
    /// Remote latching capability
    pub const REMOTE_LATCHING: u8 = 0x01;
    /// Remote unlatching capability
    pub const REMOTE_UNLATCHING: u8 = 0x02;
}

// Struct definitions

#[derive(Debug, serde::Serialize)]
pub struct DimensionState {
    pub position: Option<u8>,
    pub latch: Option<bool>,
    pub speed: Option<u8>,
}

#[derive(Debug, serde::Serialize)]
pub struct RangePercent {
    pub min: Option<u8>,
    pub max: Option<u8>,
}

#[derive(Debug, serde::Serialize)]
pub struct UnitRange {
    pub min: Option<i16>,
    pub max: Option<i16>,
}

// Command encoders

/// Encode SetTarget command (0x00)
pub fn encode_set_target(position: u8, latch: bool, speed: u8) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(position)).into(),
        (1, tlv::TlvItemValueEnc::Bool(latch)).into(),
        (2, tlv::TlvItemValueEnc::UInt8(speed)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

/// Encode Step command (0x01)
pub fn encode_step(direction: StepDirection, number_of_steps: u16, speed: u8) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(direction.to_u8())).into(),
        (1, tlv::TlvItemValueEnc::UInt16(number_of_steps)).into(),
        (2, tlv::TlvItemValueEnc::UInt8(speed)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

// Attribute decoders

/// Decode CurrentState attribute (0x0000)
pub fn decode_current_state(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<DimensionState>> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        // Struct with fields
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(Some(DimensionState {
                position: item.get_int(&[0]).map(|v| v as u8),
                latch: item.get_bool(&[1]),
                speed: item.get_int(&[2]).map(|v| v as u8),
        }))
    //} else if let tlv::TlvItemValue::Null = inp {
    //    // Null value for nullable struct
    //    Ok(None)
    } else {
    Ok(None)
    //    Err(anyhow::anyhow!("Expected struct fields or null"))
    }
}

/// Decode TargetState attribute (0x0001)
pub fn decode_target_state(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<DimensionState>> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        // Struct with fields
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(Some(DimensionState {
                position: item.get_int(&[0]).map(|v| v as u8),
                latch: item.get_bool(&[1]),
                speed: item.get_int(&[2]).map(|v| v as u8),
        }))
    //} else if let tlv::TlvItemValue::Null = inp {
    //    // Null value for nullable struct
    //    Ok(None)
    } else {
    Ok(None)
    //    Err(anyhow::anyhow!("Expected struct fields or null"))
    }
}

/// Decode Resolution attribute (0x0002)
pub fn decode_resolution(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode StepValue attribute (0x0003)
pub fn decode_step_value(inp: &tlv::TlvItemValue) -> anyhow::Result<u8> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected UInt8"))
    }
}

/// Decode Unit attribute (0x0004)
pub fn decode_unit(inp: &tlv::TlvItemValue) -> anyhow::Result<ClosureUnit> {
    if let tlv::TlvItemValue::Int(v) = inp {
        ClosureUnit::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode UnitRange attribute (0x0005)
pub fn decode_unit_range(inp: &tlv::TlvItemValue) -> anyhow::Result<Option<UnitRange>> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        // Struct with fields
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(Some(UnitRange {
                min: item.get_int(&[0]).map(|v| v as i16),
                max: item.get_int(&[1]).map(|v| v as i16),
        }))
    //} else if let tlv::TlvItemValue::Null = inp {
    //    // Null value for nullable struct
    //    Ok(None)
    } else {
    Ok(None)
    //    Err(anyhow::anyhow!("Expected struct fields or null"))
    }
}

/// Decode LimitRange attribute (0x0006)
pub fn decode_limit_range(inp: &tlv::TlvItemValue) -> anyhow::Result<RangePercent> {
    if let tlv::TlvItemValue::List(_fields) = inp {
        // Struct with fields
        let item = tlv::TlvItem { tag: 0, value: inp.clone() };
        Ok(RangePercent {
                min: item.get_int(&[0]).map(|v| v as u8),
                max: item.get_int(&[1]).map(|v| v as u8),
        })
    } else {
        Err(anyhow::anyhow!("Expected struct fields"))
    }
}

/// Decode TranslationDirection attribute (0x0007)
pub fn decode_translation_direction(inp: &tlv::TlvItemValue) -> anyhow::Result<TranslationDirection> {
    if let tlv::TlvItemValue::Int(v) = inp {
        TranslationDirection::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode RotationAxis attribute (0x0008)
pub fn decode_rotation_axis(inp: &tlv::TlvItemValue) -> anyhow::Result<RotationAxis> {
    if let tlv::TlvItemValue::Int(v) = inp {
        RotationAxis::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode Overflow attribute (0x0009)
pub fn decode_overflow(inp: &tlv::TlvItemValue) -> anyhow::Result<Overflow> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Overflow::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode ModulationType attribute (0x000A)
pub fn decode_modulation_type(inp: &tlv::TlvItemValue) -> anyhow::Result<ModulationType> {
    if let tlv::TlvItemValue::Int(v) = inp {
        ModulationType::from_u8(*v as u8).ok_or_else(|| anyhow::anyhow!("Invalid enum value"))
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode LatchControlModes attribute (0x000B)
pub fn decode_latch_control_modes(inp: &tlv::TlvItemValue) -> anyhow::Result<LatchControlModes> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u8)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}


// JSON dispatcher function

/// Decode attribute value and return as JSON string
/// 
/// # Parameters
/// * `cluster_id` - The cluster identifier
/// * `attribute_id` - The attribute identifier
/// * `tlv_value` - The TLV value to decode
/// 
/// # Returns
/// JSON string representation of the decoded value or error
pub fn decode_attribute_json(cluster_id: u32, attribute_id: u32, tlv_value: &crate::tlv::TlvItemValue) -> String {
    // Verify this is the correct cluster
    if cluster_id != 0x0105 {
        return format!("{{\"error\": \"Invalid cluster ID. Expected 0x0105, got {}\"}}", cluster_id);
    }
    
    match attribute_id {
        0x0000 => {
            match decode_current_state(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0001 => {
            match decode_target_state(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0002 => {
            match decode_resolution(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0003 => {
            match decode_step_value(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0004 => {
            match decode_unit(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0005 => {
            match decode_unit_range(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0006 => {
            match decode_limit_range(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0007 => {
            match decode_translation_direction(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0008 => {
            match decode_rotation_axis(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0009 => {
            match decode_overflow(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000A => {
            match decode_modulation_type(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x000B => {
            match decode_latch_control_modes(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        _ => format!("{{\"error\": \"Unknown attribute ID: {}\"}}", attribute_id),
    }
}

/// Get list of all attributes supported by this cluster
/// 
/// # Returns
/// Vector of tuples containing (attribute_id, attribute_name)
pub fn get_attribute_list() -> Vec<(u32, &'static str)> {
    vec![
        (0x0000, "CurrentState"),
        (0x0001, "TargetState"),
        (0x0002, "Resolution"),
        (0x0003, "StepValue"),
        (0x0004, "Unit"),
        (0x0005, "UnitRange"),
        (0x0006, "LimitRange"),
        (0x0007, "TranslationDirection"),
        (0x0008, "RotationAxis"),
        (0x0009, "Overflow"),
        (0x000A, "ModulationType"),
        (0x000B, "LatchControlModes"),
    ]
}

