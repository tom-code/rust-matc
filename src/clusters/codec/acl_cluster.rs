//! Generated Matter TLV encoders and decoders for Access Control Cluster
//! Cluster ID: 0x001F
//!
//! This file is automatically generated from ACL-Cluster.xml

use crate::tlv;
use anyhow;
use serde_json;


// Import serialization helpers for octet strings
use crate::clusters::helpers::{serialize_opt_bytes_as_hex};

// Enum definitions

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum AccessControlEntryAuthMode {
    /// Passcode authenticated session
    Pase = 1,
    /// Certificate authenticated session
    Case = 2,
    /// Group authenticated session
    Group = 3,
}

impl AccessControlEntryAuthMode {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            1 => Some(AccessControlEntryAuthMode::Pase),
            2 => Some(AccessControlEntryAuthMode::Case),
            3 => Some(AccessControlEntryAuthMode::Group),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<AccessControlEntryAuthMode> for u8 {
    fn from(val: AccessControlEntryAuthMode) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum AccessControlEntryPrivilege {
    /// Can read and observe all (except Access Control Cluster)
    View = 1,
    Proxyview = 2,
    /// View privileges, and can perform the primary function of this Node (except Access Control Cluster)
    Operate = 3,
    /// Operate privileges, and can modify persistent configuration of this Node (except Access Control Cluster)
    Manage = 4,
    /// Manage privileges, and can observe and modify the Access Control Cluster
    Administer = 5,
}

impl AccessControlEntryPrivilege {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            1 => Some(AccessControlEntryPrivilege::View),
            2 => Some(AccessControlEntryPrivilege::Proxyview),
            3 => Some(AccessControlEntryPrivilege::Operate),
            4 => Some(AccessControlEntryPrivilege::Manage),
            5 => Some(AccessControlEntryPrivilege::Administer),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<AccessControlEntryPrivilege> for u8 {
    fn from(val: AccessControlEntryPrivilege) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum AccessRestrictionType {
    /// Clients on this fabric are currently forbidden from reading and writing an attribute
    Attributeaccessforbidden = 0,
    /// Clients on this fabric are currently forbidden from writing an attribute
    Attributewriteforbidden = 1,
    /// Clients on this fabric are currently forbidden from invoking a command
    Commandforbidden = 2,
    /// Clients on this fabric are currently forbidden from reading an event
    Eventforbidden = 3,
}

impl AccessRestrictionType {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(AccessRestrictionType::Attributeaccessforbidden),
            1 => Some(AccessRestrictionType::Attributewriteforbidden),
            2 => Some(AccessRestrictionType::Commandforbidden),
            3 => Some(AccessRestrictionType::Eventforbidden),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<AccessRestrictionType> for u8 {
    fn from(val: AccessRestrictionType) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ChangeType {
    /// Entry or extension was changed
    Changed = 0,
    /// Entry or extension was added
    Added = 1,
    /// Entry or extension was removed
    Removed = 2,
}

impl ChangeType {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(ChangeType::Changed),
            1 => Some(ChangeType::Added),
            2 => Some(ChangeType::Removed),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<ChangeType> for u8 {
    fn from(val: ChangeType) -> Self {
        val as u8
    }
}

// Struct definitions

#[derive(Debug, serde::Serialize)]
pub struct AccessControlEntry {
    pub privilege: Option<AccessControlEntryPrivilege>,
    pub auth_mode: Option<AccessControlEntryAuthMode>,
    pub subjects: Option<Vec<u64>>,
    pub targets: Option<Vec<AccessControlTarget>>,
}

#[derive(Debug, serde::Serialize)]
pub struct AccessControlExtension {
    #[serde(serialize_with = "serialize_opt_bytes_as_hex")]
    pub data: Option<Vec<u8>>,
}

#[derive(Debug, serde::Serialize)]
pub struct AccessControlTarget {
    pub cluster: Option<u32>,
    pub endpoint: Option<u16>,
    pub device_type: Option<u32>,
}

#[derive(Debug, serde::Serialize)]
pub struct AccessRestrictionEntry {
    pub endpoint: Option<u16>,
    pub cluster: Option<u32>,
    pub restrictions: Option<Vec<AccessRestriction>>,
}

#[derive(Debug, serde::Serialize)]
pub struct AccessRestriction {
    pub type_: Option<AccessRestrictionType>,
    pub id: Option<u32>,
}

#[derive(Debug, serde::Serialize)]
pub struct CommissioningAccessRestrictionEntry {
    pub endpoint: Option<u16>,
    pub cluster: Option<u32>,
    pub restrictions: Option<Vec<AccessRestriction>>,
}

// Command encoders

/// Encode ReviewFabricRestrictions command (0x00)
pub fn encode_review_fabric_restrictions(arl: Vec<CommissioningAccessRestrictionEntry>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::Array(arl.into_iter().map(|v| {
                    let mut fields = Vec::new();
                    if let Some(x) = v.endpoint { fields.push((0, tlv::TlvItemValueEnc::UInt16(x as u16)).into()); }
                    if let Some(x) = v.cluster { fields.push((1, tlv::TlvItemValueEnc::UInt32(x as u32)).into()); }
                    if let Some(listv) = v.restrictions {
                        let inner_vec: Vec<_> = listv.into_iter().map(|inner| {
                            let mut nested_fields = Vec::new();
                                if let Some(x) = inner.type_ { nested_fields.push((0, tlv::TlvItemValueEnc::UInt8(x.to_u8())).into()); }
                                if let Some(x) = inner.id { nested_fields.push((1, tlv::TlvItemValueEnc::UInt32(x as u32)).into()); }
                            (0, tlv::TlvItemValueEnc::StructAnon(nested_fields)).into()
                        }).collect();
                        fields.push((2, tlv::TlvItemValueEnc::Array(inner_vec)).into());
                    }
                    (0, tlv::TlvItemValueEnc::StructAnon(fields)).into()
                }).collect())).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

// Attribute decoders

/// Decode ACL attribute (0x0000)
pub fn decode_acl(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<AccessControlEntry>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(AccessControlEntry {
                privilege: item.get_int(&[1]).and_then(|v| AccessControlEntryPrivilege::from_u8(v as u8)),
                auth_mode: item.get_int(&[2]).and_then(|v| AccessControlEntryAuthMode::from_u8(v as u8)),
                subjects: {
                    if let Some(tlv::TlvItemValue::List(l)) = item.get(&[3]) {
                        let items: Vec<u64> = l.iter().filter_map(|e| { if let tlv::TlvItemValue::Int(v) = &e.value { Some(*v) } else { None } }).collect();
                        Some(items)
                    } else {
                        None
                    }
                },
                targets: {
                    if let Some(tlv::TlvItemValue::List(l)) = item.get(&[4]) {
                        let mut items = Vec::new();
                        for list_item in l {
                            items.push(AccessControlTarget {
                cluster: list_item.get_int(&[0]).map(|v| v as u32),
                endpoint: list_item.get_int(&[1]).map(|v| v as u16),
                device_type: list_item.get_int(&[2]).map(|v| v as u32),
                            });
                        }
                        Some(items)
                    } else {
                        None
                    }
                },
            });
        }
    }
    Ok(res)
}

/// Decode Extension attribute (0x0001)
pub fn decode_extension(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<AccessControlExtension>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(AccessControlExtension {
                data: item.get_octet_string_owned(&[1]),
            });
        }
    }
    Ok(res)
}

/// Decode SubjectsPerAccessControlEntry attribute (0x0002)
pub fn decode_subjects_per_access_control_entry(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected UInt16"))
    }
}

/// Decode TargetsPerAccessControlEntry attribute (0x0003)
pub fn decode_targets_per_access_control_entry(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected UInt16"))
    }
}

/// Decode AccessControlEntriesPerFabric attribute (0x0004)
pub fn decode_access_control_entries_per_fabric(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected UInt16"))
    }
}

/// Decode CommissioningARL attribute (0x0005)
pub fn decode_commissioning_arl(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<CommissioningAccessRestrictionEntry>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(CommissioningAccessRestrictionEntry {
                endpoint: item.get_int(&[0]).map(|v| v as u16),
                cluster: item.get_int(&[1]).map(|v| v as u32),
                restrictions: {
                    if let Some(tlv::TlvItemValue::List(l)) = item.get(&[2]) {
                        let mut items = Vec::new();
                        for list_item in l {
                            items.push(AccessRestriction {
                type_: list_item.get_int(&[0]).and_then(|v| AccessRestrictionType::from_u8(v as u8)),
                id: list_item.get_int(&[1]).map(|v| v as u32),
                            });
                        }
                        Some(items)
                    } else {
                        None
                    }
                },
            });
        }
    }
    Ok(res)
}

/// Decode ARL attribute (0x0006)
pub fn decode_arl(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<AccessRestrictionEntry>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(AccessRestrictionEntry {
                endpoint: item.get_int(&[0]).map(|v| v as u16),
                cluster: item.get_int(&[1]).map(|v| v as u32),
                restrictions: {
                    if let Some(tlv::TlvItemValue::List(l)) = item.get(&[2]) {
                        let mut items = Vec::new();
                        for list_item in l {
                            items.push(AccessRestriction {
                type_: list_item.get_int(&[0]).and_then(|v| AccessRestrictionType::from_u8(v as u8)),
                id: list_item.get_int(&[1]).map(|v| v as u32),
                            });
                        }
                        Some(items)
                    } else {
                        None
                    }
                },
            });
        }
    }
    Ok(res)
}


// JSON dispatcher function

/// Decode attribute value and return as JSON string
/// 
/// # Parameters
/// * `cluster_id` - The cluster identifier
/// * `attribute_id` - The attribute identifier
/// * `tlv_value` - The TLV value to decode
/// 
/// # Returns
/// JSON string representation of the decoded value or error
pub fn decode_attribute_json(cluster_id: u32, attribute_id: u32, tlv_value: &crate::tlv::TlvItemValue) -> String {
    // Verify this is the correct cluster
    if cluster_id != 0x001F {
        return format!("{{\"error\": \"Invalid cluster ID. Expected 0x001F, got {}\"}}", cluster_id);
    }
    
    match attribute_id {
        0x0000 => {
            match decode_acl(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0001 => {
            match decode_extension(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0002 => {
            match decode_subjects_per_access_control_entry(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0003 => {
            match decode_targets_per_access_control_entry(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0004 => {
            match decode_access_control_entries_per_fabric(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0005 => {
            match decode_commissioning_arl(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0006 => {
            match decode_arl(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        _ => format!("{{\"error\": \"Unknown attribute ID: {}\"}}", attribute_id),
    }
}

/// Get list of all attributes supported by this cluster
/// 
/// # Returns
/// Vector of tuples containing (attribute_id, attribute_name)
pub fn get_attribute_list() -> Vec<(u32, &'static str)> {
    vec![
        (0x0000, "ACL"),
        (0x0001, "Extension"),
        (0x0002, "SubjectsPerAccessControlEntry"),
        (0x0003, "TargetsPerAccessControlEntry"),
        (0x0004, "AccessControlEntriesPerFabric"),
        (0x0005, "CommissioningARL"),
        (0x0006, "ARL"),
    ]
}

