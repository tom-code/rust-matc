//! Generated Matter TLV encoders and decoders for Access Control Cluster
//! Cluster ID: 0x001F
//! 
//! This file is automatically generated from ACL-Cluster.xml

use crate::tlv;
use anyhow;
use serde_json;


// Struct definitions

#[derive(Debug, serde::Serialize)]
pub struct AccessControlEntry {
    pub privilege: Option<u8>,
    pub auth_mode: Option<u8>,
    pub subjects: Option<Vec<u64>>,
    pub targets: Option<Vec<AccessControlTarget>>,
}

#[derive(Debug, serde::Serialize)]
pub struct AccessControlExtension {
    pub data: Option<Vec<u8>>,
}

#[derive(Debug, serde::Serialize)]
pub struct AccessControlTarget {
    pub cluster: Option<u32>,
    pub endpoint: Option<u16>,
    pub device_type: Option<u32>,
}

#[derive(Debug, serde::Serialize)]
pub struct AccessRestrictionEntry {
    pub endpoint: Option<u16>,
    pub cluster: Option<u32>,
    pub restrictions: Option<Vec<AccessRestriction>>,
}

#[derive(Debug, serde::Serialize)]
pub struct AccessRestriction {
    pub type_: Option<u8>,
    pub id: Option<u32>,
}

#[derive(Debug, serde::Serialize)]
pub struct CommissioningAccessRestrictionEntry {
    pub endpoint: Option<u16>,
    pub cluster: Option<u32>,
    pub restrictions: Option<Vec<AccessRestriction>>,
}

// Command encoders

/// Encode ReviewFabricRestrictions command (0x00)
pub fn encode_review_fabric_restrictions(arl: Vec<u8>) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::StructAnon(arl.into_iter().map(|v| (0, tlv::TlvItemValueEnc::UInt8(v)).into()).collect())).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

// Attribute decoders

/// Decode ACL attribute (0x0000)
pub fn decode_acl(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<AccessControlEntry>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(AccessControlEntry {
                privilege: item.get_int(&[1]).map(|v| v as u8),
                auth_mode: item.get_int(&[2]).map(|v| v as u8),
                subjects: {
                    if let Some(tlv::TlvItemValue::List(l)) = item.get(&[3]) {
                        let items: Vec<u64> = l.iter().filter_map(|e| {
                            if let tlv::TlvItemValue::Int(v) = &e.value {
                                Some(*v)
                            } else {
                                None
                            }
                        }).collect();
                        Some(items)
                    } else {
                        None
                    }
                },
                targets: {
                    if let Some(tlv::TlvItemValue::List(l)) = item.get(&[4]) {
                        let mut items = Vec::new();
                        for list_item in l {
                            items.push(AccessControlTarget {
                                cluster: list_item.get_int(&[0]).map(|v| v as u32),
                                endpoint: list_item.get_int(&[1]).map(|v| v as u16),
                                device_type: list_item.get_int(&[2]).map(|v| v as u32),
                            });
                        }
                        Some(items)
                    } else {
                        None
                    }
                },
            });
        }
    }
    Ok(res)
}

/// Decode Extension attribute (0x0001)
pub fn decode_extension(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<AccessControlExtension>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(AccessControlExtension {
                data: item.get_octet_string_owned(&[1]),
            });
        }
    }
    Ok(res)
}

/// Decode SubjectsPerAccessControlEntry attribute (0x0002)
pub fn decode_subjects_per_access_control_entry(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode TargetsPerAccessControlEntry attribute (0x0003)
pub fn decode_targets_per_access_control_entry(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode AccessControlEntriesPerFabric attribute (0x0004)
pub fn decode_access_control_entries_per_fabric(inp: &tlv::TlvItemValue) -> anyhow::Result<u16> {
    if let tlv::TlvItemValue::Int(v) = inp {
        Ok(*v as u16)
    } else {
        Err(anyhow::anyhow!("Expected Integer"))
    }
}

/// Decode CommissioningARL attribute (0x0005)
pub fn decode_commissioning_arl(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<CommissioningAccessRestrictionEntry>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(CommissioningAccessRestrictionEntry {
                endpoint: item.get_int(&[0]).map(|v| v as u16),
                cluster: item.get_int(&[1]).map(|v| v as u32),
                restrictions: {
                    if let Some(tlv::TlvItemValue::List(l)) = item.get(&[2]) {
                        let mut items = Vec::new();
                        for list_item in l {
                            items.push(AccessRestriction {
                                type_: list_item.get_int(&[0]).map(|v| v as u8),
                                id: list_item.get_int(&[1]).map(|v| v as u32),
                            });
                        }
                        Some(items)
                    } else {
                        None
                    }
                },
            });
        }
    }
    Ok(res)
}

/// Decode ARL attribute (0x0006)
pub fn decode_arl(inp: &tlv::TlvItemValue) -> anyhow::Result<Vec<AccessRestrictionEntry>> {
    let mut res = Vec::new();
    if let tlv::TlvItemValue::List(v) = inp {
        for item in v {
            res.push(AccessRestrictionEntry {
                endpoint: item.get_int(&[0]).map(|v| v as u16),
                cluster: item.get_int(&[1]).map(|v| v as u32),
                restrictions: {
                    if let Some(tlv::TlvItemValue::List(l)) = item.get(&[2]) {
                        let mut items = Vec::new();
                        for list_item in l {
                            items.push(AccessRestriction {
                                type_: list_item.get_int(&[0]).map(|v| v as u8),
                                id: list_item.get_int(&[1]).map(|v| v as u32),
                            });
                        }
                        Some(items)
                    } else {
                        None
                    }
                },
            });
        }
    }
    Ok(res)
}


// JSON dispatcher function

/// Decode attribute value and return as JSON string
/// 
/// # Parameters
/// * `cluster_id` - The cluster identifier
/// * `attribute_id` - The attribute identifier
/// * `tlv_value` - The TLV value to decode
/// 
/// # Returns
/// JSON string representation of the decoded value or error
pub fn decode_attribute_json(cluster_id: u32, attribute_id: u32, tlv_value: &crate::tlv::TlvItemValue) -> String {
    // Verify this is the correct cluster
    if cluster_id != 0x001F {
        return format!("{{\"error\": \"Invalid cluster ID. Expected 0x001F, got {}\"}}", cluster_id);
    }
    
    match attribute_id {
        0x0000 => {
            match decode_acl(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0001 => {
            match decode_extension(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0002 => {
            match decode_subjects_per_access_control_entry(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0003 => {
            match decode_targets_per_access_control_entry(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0004 => {
            match decode_access_control_entries_per_fabric(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0005 => {
            match decode_commissioning_arl(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        0x0006 => {
            match decode_arl(tlv_value) {
                Ok(value) => serde_json::to_string(&value).unwrap_or_else(|_| "null".to_string()),
                Err(e) => format!("{{\"error\": \"{}\"}}", e),
            }
        }
        _ => format!("{{\"error\": \"Unknown attribute ID: {}\"}}", attribute_id),
    }
}

/// Get list of all attributes supported by this cluster
/// 
/// # Returns
/// Vector of tuples containing (attribute_id, attribute_name)
pub fn get_attribute_list() -> Vec<(u32, &'static str)> {
    vec![
        (0x0000, "ACL"),
        (0x0001, "Extension"),
        (0x0002, "SubjectsPerAccessControlEntry"),
        (0x0003, "TargetsPerAccessControlEntry"),
        (0x0004, "AccessControlEntriesPerFabric"),
        (0x0005, "CommissioningARL"),
        (0x0006, "ARL"),
    ]
}

