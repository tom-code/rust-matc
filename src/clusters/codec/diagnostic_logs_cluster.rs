//! Generated Matter TLV encoders and decoders for Diagnostic Logs Cluster
//! Cluster ID: 0x0032
//!
//! This file is automatically generated from DiagnosticLogsCluster.xml

use crate::tlv;
use anyhow;


// Enum definitions

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum Intent {
    /// Logs to be used for end-user support
    Endusersupport = 0,
    /// Logs to be used for network diagnostics
    Networkdiag = 1,
    /// Obtain crash logs from the Node
    Crashlogs = 2,
}

impl Intent {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(Intent::Endusersupport),
            1 => Some(Intent::Networkdiag),
            2 => Some(Intent::Crashlogs),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<Intent> for u8 {
    fn from(val: Intent) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum Status {
    /// Successful transfer of logs
    Success = 0,
    /// All logs have been transferred
    Exhausted = 1,
    /// No logs of the requested type available
    Nologs = 2,
    /// Unable to handle request, retry later
    Busy = 3,
    /// The request is denied, no logs being transferred
    Denied = 4,
}

impl Status {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(Status::Success),
            1 => Some(Status::Exhausted),
            2 => Some(Status::Nologs),
            3 => Some(Status::Busy),
            4 => Some(Status::Denied),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<Status> for u8 {
    fn from(val: Status) -> Self {
        val as u8
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum TransferProtocol {
    /// Logs to be returned as a response
    Responsepayload = 0,
    /// Logs to be returned using BDX
    Bdx = 1,
}

impl TransferProtocol {
    /// Convert from u8 value
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(TransferProtocol::Responsepayload),
            1 => Some(TransferProtocol::Bdx),
            _ => None,
        }
    }

    /// Convert to u8 value
    pub fn to_u8(self) -> u8 {
        self as u8
    }
}

impl From<TransferProtocol> for u8 {
    fn from(val: TransferProtocol) -> Self {
        val as u8
    }
}

// Command encoders

/// Encode RetrieveLogsRequest command (0x00)
pub fn encode_retrieve_logs_request(intent: Intent, requested_protocol: TransferProtocol, transfer_file_designator: String) -> anyhow::Result<Vec<u8>> {
    let tlv = tlv::TlvItemEnc {
        tag: 0,
        value: tlv::TlvItemValueEnc::StructInvisible(vec![
        (0, tlv::TlvItemValueEnc::UInt8(intent.to_u8())).into(),
        (1, tlv::TlvItemValueEnc::UInt8(requested_protocol.to_u8())).into(),
        (2, tlv::TlvItemValueEnc::String(transfer_file_designator)).into(),
        ]),
    };
    Ok(tlv.encode()?)
}

